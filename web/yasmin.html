<!DOCTYPE html><html lang="en"><head><title>YASMIN</title><meta http-equiv=Content-Type content="text/html; charset=utf-8"><style type="text/css">
body {font-size:10pt;color:#000000;font-family:verdana,arial;background-color:white;margin:10pt}
span.cmt {font-size: 10pt;font-family: verdana,arial;font-weight:normal;font-style:italic;color:gray}
pre {margin-left:30pt}
div {width:800pt;margin-top:15pt}
div.header {font-size:14pt;width:800pt;margin-top:12pt;margin-bottom:5pt}
div.new {width:800pt;margin-top:5pt}

</style></head><body>
<div><img src="yasmin-logo.svg" title="YASMIN"alt="N/A" style="width:210pt;display:block;margin-left:auto;margin-right:auto;margin-top:35pt;margin-bottom:30pt"></div>
<div>
YASMIN (Yet Another jSon Message notatIoN), was designed to offer an alternative to
<a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">REST</a> based APIs, by bringing the following
enhancements to the table:
<ul>
<li>Support for event based communication like
<a href="https://tools.ietf.org/rfc/rfc6455.txt" target="_blank">WebSocket</a>
and
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank">postMessage()</a></li>
<li>Unified signature <i>option</i> for requests and responses</li>
<li>Unified serialization and deserializing methods for requests and responses</li>
</ul>
</div>
<div class="new">
Note: If you are looking for an API you won't find one because the core
is a <i>message-centric</i> concept, where &quot;self-sufficient&quot; messages using
<a href="https://tools.ietf.org/rfc/rfc7159.txt" target="_blank">JSON</a> syntax
have been &quot;liberated&quot;
from interfering HTTP bindings, URIs, and clunky <a href="https://www.w3.org/TR/soap12/" target="_blank">SOAP</a> envelopes.
   However, nothing prevents you from mapping APIs into messages!
</div>
<div class="new">
Code examples are if not stated otherwise provided in JavaScript.
</div>
<div>
<div class="header" id="messages">Message Structure</div>
One of the requirements (derived from XML and XML Schema),
was the ability recognizing the <i>type</i> of a message (object) by including such information in the message itself.
This allows you to process different messages through a single dispatcher mechanism as well
as easing debugging and documentation.  The following message taken from the
<a href="https://cyberphone.github.io/doc/saturn" target="_blank">Saturn</a>
project shows the <i>recommended</i> typing scheme:
<div style="margin:10pt 0pt 0pt 30pt;font-size:9pt;word-break:break-all;width:700pt;background:#F8F8F8;border-width:1px;border-style:solid;border-color:grey;padding:10pt;box-shadow:3pt 3pt 3pt #D0D0D0">{<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#606060">@context</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">http://webpki.org/saturn/v3</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#606060">@qualifier</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">PayeeAuthority</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">authorityUrl</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">https://payments.bigbank.com/payees/86344</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">providerAuthorityUrl</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">https://payments.bigbank.com/authority</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">commonName</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">Demo Merchant</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">id</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">86344</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">publicKey</span>&quot;:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">type</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">EC</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">curve</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">P-256</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">x</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">rZ344aiTaOATmLBOdfYThvnQu_zyB1aJZrbbbks2P9I</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">y</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">lKOvfJdgN8WqEbXMDYPRSMsPicm0Tk10pmer9LxvxLg</span>&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">timeStamp</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">2017-01-21T07:04:30Z</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">expires</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">2017-01-21T08:04:31Z</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">signature</span>&quot;:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">algorithm</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">ES256</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">signerCertificate</span>&quot;:&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">issuer</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">CN=Payment Network Sub CA3,C=EU</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">serialNumber</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">1461174554959</span>&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">subject</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">CN=Big Bank,2.5.4.5=#1306383936363430,C=DE</span>&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">certificatePath</span>&quot;:&nbsp;[&quot;<span style="color:#0000C0">MIIBtTCCAVmgAwIB....sApiD3jFnqaJhxCZ</span>&quot;,&quot;<span style="color:#0000C0">MIIDcjCCAVqgAwIB....e_-5TddhlTUMNPvw</span>&quot;],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span style="color:#C00000">value</span>&quot;:&nbsp;&quot;<span style="color:#0000C0">qP4qAYj4FW4j42Moq6wd2wzHGUN2_Pjd....R4nuX_Oi-aLznRJZiP_B-zSnRaMVsdMg</span>&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></div>
</div>
<div>
The <code>@context</code> property is essentially a counterpart to an XML name-space,
while <code>@qualifier</code> emulates an XML top-level element.
In a typical implementation, <code>@context</code> is a constant while <code>@qualifier</code> denotes actual message type.
The point with having designated &quot;keywords&quot; for type information is that you can
automate object instantiation.
</div>
<div>
<div class="new" style="border-width:1pt;border-color:black;border-style:solid;padding:6pt 12pt 6pt 12pt;width:620pt;display:block;margin-left:auto;margin-right:auto">
A major advantage with typed (and self-contained) messages is that they become <i>transport-independent</i>,
allowing them to be embedded in HTML pages, sent over NFC,
or be pushed through various proxies without loosing their meaning.
</div>
</div>
<div style="margin-top:0pt">
&nbsp;
<div class="header" id="http-operation">Sending Messages over HTTP</div>
Requests containing (JSON formatted) transaction data should be invoked by HTTP POST
while requests that only lookup existing data should use GET.
Successful requests including &quot;soft&quot; (handled) errors like
&quot;Insufficient Funds&quot; should return HTTP&nbsp;200,
while &quot;hard&quot; (non-recoverable) errors should return an applicable HTTP code like 400, 401, 404, 405, 500
plus a suitable text message for logging and debugging purposes.
</div>
<div class="new">
POSTed messages are preferably <i>idempotent</i> within their validity time to facilitate <i>secure retransmissions</i>.
</div>
<div class="new">
Below is an example of a POSTed transaction request:
<pre>
POST /transact HTTP/1.1
User-Agent: Java
Host: saturn.mybank.com
Content-Type: application/json                                   <span class="cmt">Mandatory MIME type</span>
Content-Length: 1234

{
  "@context":"some-name-space",
  "@qualifier":"some-object-type",

       <span class="cmt">Additional Transaction Payload Request Properties</span>

  "signature":{...}                                              <span class="cmt">Optional signature</span>
}
</pre>
        GET and POST responses follow the same pattern:
<pre>
HTTP/1.1 200 OK
Content-Type: application/json                                   <span class="cmt">Mandatory MIME type</span>
Content-Length: 9541
{
  "@context":"some-name-space",
  "@qualifier":"some-object-type",

       <span class="cmt">Additional Response Properties</span>

  "signature":{...}                                              <span class="cmt">Optional signature</span>
}
</pre>
</div>

<div>
<div class="header" id="serialization">Message Serialization and Deserialization (Parsing)</div>
<table style="margin-left:30pt"><tr>
<td><i> JSON String</i><code> = <span style="color:brown">JSON</span>.<span style="color:red">stringify</span>(</code><i>JavaScript Object</i><code>);</code></td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td><code><span style="color:grey">// I don't like complexity!</span></code></td></tr>
<tr><td><i>JavaScript Object</i><code> = <span style="color:brown">JSON</span>.<span style="color:red">parse</span>(</code><i>JSON String</i><code>);</code></td>
<td></td><td><code><span style="color:grey">// Me neither :-)</span></code></td>
</tr></table>
</div>
<div>
<div class="header" id="signatures">Signed JSON (and JavaScript) Messages</div>
The vision was to have something similar to
<a href="https://www.w3.org/TR/xmldsig-core/" target="_blank">XML&nbsp;DSig</a>
but preferably not depending on megabytes of fairly intricate library code.
Although the IETF JOSE WG had recently defined a set of JSON based cryptographic standards,
the JOSE signature scheme forced you to encode messages in <code>Base64Url</code>
which did not only made them <i>unreadable by humans</i>, but also <i>disrupted the message typing scheme</i>.
</div>
<div>
<div class="new" style="border-width:1pt;border-color:black;border-style:solid;padding:6pt 12pt 6pt 12pt;width:620pt;display:block;margin-left:auto;margin-right:auto">
Since existing JSON signature solutions did not fit the targeted scenarios,
a new signature scheme had to be developed which (completely unintentional),
turned out to be compatible with recent versions of JavaScript as well!
</div>
</div>
<div>
For more information on the signature system turn to
<a href="https://cyberphone.github.io/doc/security/jsonsignatures.html" target="_blank">https://cyberphone.github.io/doc/security/jsonsignatures.html</a>.
</div>
<div class="new">
To maintain a &quot;style compatible&quot; messaging concept, a matching encryption scheme was also
added to the plot: <a href="https://cyberphone.github.io/doc/security/jef.html" target="_blank">https://cyberphone.github.io/doc/security/jef.html</a>.
</div>
<div>
<div class="header" id="handlers">Message Handlers and Decoders</div>
The devised scheme does not specify whether all transaction requests should go to a single handler
(servlet) and URI,
but in the case a handler supports more than one transaction (message) type you need to dispatch
messages to the proper sub-handler.  This is trivial using typed messages here expressed in JavaScript:
</div>
<div class="new">
<pre>
<span style="color:blue">var</span> input = <span style="color:brown">JSON</span>.<span style="color:red">parse</span>(<span style="color:red">readRequest</span>(request));      <span style="color:grey">// Hypothetical metod: "readRequest()"</span>
<span style="color:blue">var</span> output;
<span style="color:blue">switch</span> (input['<span style="color:green">@qualifier</span>']) {
  <span style="color:blue">case</span> '<span style="color:green">Authorize</span>':
    output = <span style="color:red">authorize</span>(input);                     <span style="color:grey">// Hypothetical metod: "authorize()"</span>
    <span style="color:blue">break</span>;
  <span style="color:blue">case</span> '<span style="color:green">CommitPayment</span>':
    output = <span style="color:red">commitPayment</span>(input);                 <span style="color:grey">// Hypothetical metod: "commitPayment()"</span>
    <span style="color:blue">break</span>;
  <span style="color:blue">default</span>:
    <span style="color:blue">throw new</span> <span style="color:brown">TypeError</span>('<span style="color:green">Unrecognized Message</span>');
}
<span style="color:red">writeResponse</span>(response, <span style="color:brown">JSON</span>.<span style="color:red">stringify</span>(output));   <span style="color:grey">// Hypothetical metod: "writeResponse()"</span>
</pre>
</div>
<div>
<div class="header" id="applications">Other Uses of the Messaging Platform</div>
Since the net result of the measures above, effectively is a &quot;Messaging Platform&quot;, it would
probably be interesting if it could be used for something else than just the original (rather narrow) target, right?
<div>
<div class="new" style="border-width:1pt;border-color:black;border-style:solid;padding:6pt 12pt 6pt 12pt;width:550pt;display:block;margin-left:auto;margin-right:auto">
Due to the scheme's <i>transport independence</i>, <i>JavaScript compatibility</i>, and support for
<i>non-intrusive signatures</i>, it should be equally usable for entirely different categories of
applications, including client-centric security-related applications like &quot;wallets&quot;,
user authentication solutions, and credential enrollment.
</div>
</div>
<div>
<div class="new">
This has been successfully verified in a number of proof-of-concept applications including:
<a href="https://test.webpki.org/webpay-merchant" target="_blank">https://test.webpki.org/webpay-merchant</a>.
</div>
</div>
</div>
<div style="margin-top:30pt">V0.51, A.Rundgren, 2017-01-24</div></body></html>