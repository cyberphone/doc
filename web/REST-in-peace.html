<!DOCTYPE html><html><head><title>REST (.In.Peace)</title><meta http-equiv=Content-Type content="text/html; charset=utf-8"><style type="text/css">
body {font-size:10pt;color:#000000;font-family:verdana,arial;background-color:white;margin:10pt}
code {font-size:11pt;font-family:'Courier New',Courier}
pre {margin-left:30pt;font-size:11pt;font-family:'Courier New',Courier}
div {width:800pt;margin-top:10pt}
div.header {width:800pt;margin-top:10pt;margin-bottom:5pt;font-weight:bold}
div.new {width:800pt;margin-top:5pt}

</style></head><body>
<div><img src="REST-in-peace.png" style="display:block;margin-left:auto;margin-right:auto"></div>
<div style="font-size:15pt;margin:10pt;font-family:arial,verdana;text-align:center">
A Somewhat Critical Analysis of REST as the &quot;Final Solution&quot;
</div>
<div>
<i>Disclaimer</i>: This is not an
<a href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank">academic paper</a>,
it is simply a set of personal observations that I have
made during my fairly long journey with Web (HTTP) based business systems.
You don't have to agree with it at all :-)
</div>
<div>
Since everybody in IT who haven't slept under a rock the last 10 years know, REST has become almost synonmous with
good Web API design (although most developers tend to refer to their designs as &quot;REST-ful&quot; to permit
some freedom of the interpretation what REST actually is...).
</div>
<div class="new">
In spite of that, I have for a <i>certain class of applications</i> which we can
call &quot;Transaction Systems&quot;
come to the conclusion that REST may not nessesarli be the most logical choice.
The reasons are briefly described in the following sections.  Transaction systems (using my vocabolary NB),
for example include B2B order/invoicing and bank-to-bank payments.  
</div>
<div>
<div class="header">Web Services, SOAP, and XML are Obsolete!</div>
Indeed, after more than 10 years with SOAP, XML and XML Schemas, I have 
decided to never (by free will at least) work with this more.
However, that's not equivakent with &quot;<i>Everything was wrong with Web Services</i>&quot; which
REST advocates often claim.
You can safely drop SOAP, XML can be replaced by JSON, but the underlaying
RPC-concept still has plenty of milage which I will get back to in the end of this paper.
</div>
<div>
<div class="header">REST - Stateless Operation</div>
Stateless operation is great but transactions are typically not stateless so it is hard
to see that REST has anything special to offer here.
Excisting, non-REST transaction systems usually do not depend on Web server state either.
</div>
<div>
<div class="header">REST - Asynchronous Operation</div>
This is a more complex issue but if I understand the philosophy REST correctly,
a long-winding transaction request should preferable not block until it is ready, but return HTTP&nbsp;201
and a header holding a URI to a location where the result may be quirued for.
</div>
<div class="new">
IMHO, this greatly complicates the design in both ends; The server must
still continue with the processing (albeit in the background) including
dealing with possible time-outs, and then when a result is ready
move it to a handler for the previously calculated URI.
<div class="new">
For clients <i>that are not browsers</i>, but &quot;Business Systems&quot;, it gets worse;
after sending the request, the client needs to start a process for quiring the result using
the previously received URI,
and finally pairing the result with the original request.
There may of course be a time-out here as well.
</div>
<div class="new">
To me this looks pretty much like reinvented SMTP, using HTTP and Web servers.
</div>
<div class="new">
Recent EU directives (SCT Inst) require payment transactions to finisih in less than 10 seconds while
card network operations already typically take less than 1 second which
does not motivate asynchrounous operation.
Of course there are some slow (mail based), systems out there which could benefit from a scheme
like above but that does not (at all) imply that you need to buy into in the whole REST paradigm as well.
</div>
<div>
<div class="header">REST - HTTP Bindings</div>
Although not directly related to our class of applications it is still worth mentioning
that REST is claimed to not be limited to HTTP. This may be true, but
it is not entirely obvious how a scheme based on <i>URIs</i>, <i>HTTP Header Parameters</i>,
<i>HTTP Verbs</i>, and an <i>Optional Request Body</i>, could be translated to other transports.
In fact, REST appears to even be incompatible with
<a href="https://tools.ietf.org/rfc/rfc6455.txt" target="_blank">WebSockets</a> (another cool Web technology).
</div>
<div>
<div class="header">REST - Serialization</div>
A common feature of transacton systems, is storing transaction data.
Since the meaning of a REST request is not uniquely defined by
the &quot;payload&quot;, a complete store operation would (presumably)
include HTTP verb, URI, and HTTP headers as well.
Doable but also rather messy compared to &quot;old-school&quot; self contained XML messages.
</div>
<div class="header">REST - Signed Requests</div>
Believe it or not, but <i>there is currently no established standard for signing REST requests</i>.
</div>
<div class="new">
Well, when you look more closely into the matter, you will
find that a major hurdle is that a <i>proper</i> signature scheme should sign <i>all
elements</i> characterizing the meaning (sematics) of a
request which for REST also include HTTP verb, URI, and HTTP headers,
making conicalization awkward. 
</div>
<div class="new">
Here is a scheme used by Amazon.com: 
<a href="http://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html" target="_blank">
http://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html</a>.
</div>
<div class="new">
If you to the above add <i>countersigned</i> messages which is a useful feature in transaction
systems, you end-up with an <i>ugly mixture</i> of JSON and non-JSON data.
</div>
<div style="font-size:15pt;margin:10pt;font-family:arial,verdana;text-align:center">
Another Way Forward
</div>
<div>
The following sections outline a scheme which I consider a viable alternative to
REST based transaction systems.  <i>The code examples are given in JavaScript</i>.
</div>
<div>
<div class="header">HTTP Bindings</div>
Requests containing (JSON formatted) transaction data are POSTed while those who do not use GET.
Successful requests including &quot;soft&quot; errors like
&quot;Insufficient Funds&quot; always return HTTP&nbsp;200,
while &quot;hard&quot; errors return an applicable HTTP code like 400, 401, 404, 405, 500
plus a suitable text message for logging and debugging purposes.
</div>
<div class="new">
POSTed messages are preferably <i>indempotent</i> within their validity time to facilitate secure <i>retransmission</i>.
</div>
<div class="new">
Below is an example of a POSTed transaction request:
<pre>
POST /transact HTTP/1.1
User-Agent: Java
Host: saturn.mybank.com
Content-Type: application/json
Content-Length: 1234

{
  "@context":"some-name-space",
  "@qualifier":"some-object-type",
</pre>
<i style="margin-left:40pt">Additional Transaction Payload Request Properties</i>
<pre>
  "signature":{...}
}
</pre>
A GET or POST response body follows the same pattern:
<pre>
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 1234

{
  "@context":"some-name-space",
  "@qualifier":"some-object-type",
</pre>
<i style="margin-left:40pt">Additional Response Properties</i>
<pre>
  "signature":{...}
}
</pre>
</div>
<div>
<div class="header">Message Serialization and Deserialization (Parsing)</div>
<i style="margin-left:30pt"> JSON String</i><code> = JSON.stringify(</code><i>JavaScript Object</i><code>);&nbsp;&nbsp;// Who likes complexity?</code>
</div>
<div class="new">
<i style="margin-left:30pt">JavaScript Object</i><code> = JSON.parse(</code><i>JSON String Data</i><code>);&nbsp;&nbsp;// Not me! :-)</code>
</div>

<br>V0.7, A.Rundgren, 2016-08-05</body></html>