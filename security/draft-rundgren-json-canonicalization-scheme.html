<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="robots" content="index,follow">
    <meta name="creator" content="rfcmarkup version 1.129b">
    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">

    <link rel="icon" href="" type="image/png">
    <link rel="shortcut icon" href="" type="image/png">
    <title>draft-rundgren-json-canonicalization-scheme-2.txt - JSON Canonicalization Scheme (JCS)</title>
    
    
    <style type="text/css">
	@media only screen 
	  and (min-width: 992px)
	  and (max-width: 1199px) {
	    body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 768px)
	  and (max-width: 991px) {
            body { font-size: 14pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-width: 480px)
	  and (max-width: 767px) {
            body { font-size: 11pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (max-width: 479px) {
            body { font-size: 8pt; }
            div.content { width: 96ex; margin: 0 auto; }
        }
	@media only screen 
	  and (min-device-width : 375px) 
	  and (max-device-width : 667px) {
            body { font-size: 9.5pt; }
            div.content { width: 96ex; margin: 0; }
        }
	@media only screen 
	  and (min-device-width: 1200px) {
            body { font-size: 10pt; margin: 0 4em; }
            div.content { width: 96ex; margin: 0; }
        }
        h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
	    font-weight: bold;
            line-height: 0pt;
            display: inline;
            white-space: pre;
            font-family: monospace;
            font-size: 1em;
	    font-weight: bold;
        }
        pre {
            font-size: 1em;
            margin-top: 0px;
            margin-bottom: 0px;
        }
	.pre {
	    white-space: pre;
	    font-family: monospace;
	}
	.header{
	    font-weight: bold;
	}
        .newpage {
            page-break-before: always;
        }
        .invisible {
            text-decoration: none;
            color: white;
        }
        a.selflink {
          color: black;
          text-decoration: none;
        }
        @media print {
            body {
                font-family: monospace;
                font-size: 10.5pt;
            }
            h1, h2, h3, h4, h5, h6 {
                font-size: 1em;
            }
        
            a:link, a:visited {
                color: inherit;
                text-decoration: none;
            }
            .noprint {
                display: none;
            }
        }
	@media screen {
	    .grey, .grey a:link, .grey a:visited {
		color: #777;
	    }
            .docinfo {
                background-color: #EEE;
            }
            .top {
                border-top: 7px solid #EEE;
            }
            .bgwhite  { background-color: white; }
            .bgred    { background-color: #F44; }
            .bggrey   { background-color: #666; }
            .bgbrown  { background-color: #840; }            
            .bgorange { background-color: #FA0; }
            .bgyellow { background-color: #EE0; }
            .bgmagenta{ background-color: #F4F; }
            .bgblue   { background-color: #66F; }
            .bgcyan   { background-color: #4DD; }
            .bggreen  { background-color: #4F4; }

            .legend   { font-size: 90%; }
            .cplate   { font-size: 70%; border: solid grey 1px; }
	}
    </style>
    <!--[if IE]>
    <style>
    body {
       font-size: 13px;
       margin: 10px 10px;
    }
    </style>
    <![endif]-->

    <script type="text/javascript"><!--
    function addHeaderTags() {
	var spans = document.getElementsByTagName("span");
	for (var i=0; i < spans.length; i++) {
	    var elem = spans[i];
	    if (elem) {
		var level = elem.getAttribute("class");
                if (level == "h1" || level == "h2" || level == "h3" || level == "h4" || level == "h5" || level == "h6") {
                    elem.innerHTML = "<"+level+">"+elem.innerHTML+"</"+level+">";		
                }
	    }
	}
    }
    var legend_html = "Colour legend:<br />      <table>         <tr><td>Unknown:</td>                   <td><span class='cplate bgwhite'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft:</td>                     <td><span class='cplate bgred'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Informational:</td>             <td><span class='cplate bgorange'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Experimental:</td>              <td><span class='cplate bgyellow'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Best Common Practice:</td>      <td><span class='cplate bgmagenta'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Proposed Standard:</td>         <td><span class='cplate bgblue'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Draft Standard (old designation):</td> <td><span class='cplate bgcyan'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Internet Standard:</td>         <td><span class='cplate bggreen'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Historic:</td>                  <td><span class='cplate bggrey'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>         <tr><td>Obsolete:</td>                  <td><span class='cplate bgbrown'>&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr>     </table>";
    function showElem(id) {
        var elem = document.getElementById(id);
        elem.innerHTML = eval(id+"_html");
        elem.style.visibility='visible';
    }
    function hideElem(id) {
        var elem = document.getElementById(id);
        elem.style.visibility='hidden';        
        elem.innerHTML = "";
    }
    // -->
    </script>
</head>
<body onload="addHeaderTags()">
  <div class="content">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';" onclick="showElem('legend');" onmouseout="hideElem('legend')" style="height: 6px; position: absolute;" class="pre noprint docinfo " title="Click for colour legend.">                                                                        </div>
      <div id="legend" class="docinfo noprint pre legend" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; " onmouseover="showElem('legend');" onmouseout="hideElem('legend');">
      </div>
   </div>

<span class="pre noprint docinfo">                                                                        </span><br>
<span class="pre noprint docinfo">                                                                        </span><br>
<span class="pre noprint docinfo">                                                                        </span><br>
<pre>Network Working Group                                        A. Rundgren
Internet-Draft                                               Independent
Intended status: Standards Track                               B. Jordan
Expires: July 23, 2019                              Symantec Corporation
                                                              S. Erdtman
                                                              Spotify AB
                                                        January 19, 2019


                   <span class="h1"><h1>JSON Canonicalization Scheme (JCS)</h1></span>
             <span class="h1"><h1>draft-rundgren-json-canonicalization-scheme-03</h1></span>

Abstract

   Cryptographic operations like hashing and signing requires that the
   target data does not change during serialization or parsing.  By
   applying the rules defined by the JSON Canonicalization Scheme (JCS),
   data provided in JSON [<a href="http://tools.ietf.org/html//rfc8259" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC8259</a>] format can be exchanged "as is",
   while still being subject to secure cryptographic operations.  JCS
   achieves this by building on the serialization formats for JSON
   primitives as defined by ECMAScript [<a href="#ref-ES6" title="&quot;ECMAScript 2015 Language Specification&quot;">ES6</a>], constraining JSON data to
   the I-JSON [<a href="http://tools.ietf.org/html//rfc7493" title="&quot;The I-JSON Message Format&quot;">RFC7493</a>] subset, and through a platform independent
   property sorting scheme.

   The intended audiences of this document are JSON tool vendors, as
   well as designers of JSON based cryptographic solutions.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of <a href="http://tools.ietf.org/html//bcp78">BCP 78</a> and <a href="http://tools.ietf.org/html//bcp79">BCP 79</a>.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at <a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a>.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on July 23, 2019.








<span class="grey">Rundgren, et al.          Expires July 23, 2019                 [Page 1]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-2" id="page-2" href="#page-2" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to <a href="http://tools.ietf.org/html//bcp78">BCP 78</a> and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   <a href="#section-1">1</a>.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-2">2</a>.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-3">3</a>
   <a href="#section-3">3</a>.  Detailed Operation  . . . . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-3.1">3.1</a>.  Creation of JSON Data . . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
     <a href="#section-3.2">3.2</a>.  Canonicalization of JSON Data . . . . . . . . . . . . . .   <a href="#page-4">4</a>
       <a href="#section-3.2.1">3.2.1</a>.  Whitespace Handling . . . . . . . . . . . . . . . . .   <a href="#page-4">4</a>
       <a href="#section-3.2.2">3.2.2</a>.  Serialization of Primitive Data Types . . . . . . . .   <a href="#page-4">4</a>
         <a href="#section-3.2.2.1">3.2.2.1</a>.  Serialization of Literals . . . . . . . . . . . .   <a href="#page-5">5</a>
         <a href="#section-3.2.2.2">3.2.2.2</a>.  Serialization of Strings  . . . . . . . . . . . .   <a href="#page-5">5</a>
         <a href="#section-3.2.2.3">3.2.2.3</a>.  Serialization of Numbers  . . . . . . . . . . . .   <a href="#page-6">6</a>
       <a href="#section-3.2.3">3.2.3</a>.  Sorting of Object Properties  . . . . . . . . . . . .   <a href="#page-6">6</a>
       <a href="#section-3.2.4">3.2.4</a>.  UTF-8 Generation  . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-4">4</a>.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-5">5</a>.  Security Considerations . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-6">6</a>.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-8">8</a>
   <a href="#section-7">7</a>.  References  . . . . . . . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-7.1">7.1</a>.  Normative References  . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-7.2">7.2</a>.  Informal References . . . . . . . . . . . . . . . . . . .   <a href="#page-9">9</a>
     <a href="#section-7.3">7.3</a>.  URIs  . . . . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#appendix-A">Appendix A</a>.  ES6 Sample Canonicalizer . . . . . . . . . . . . . .  <a href="#page-10">10</a>
   <a href="#appendix-B">Appendix B</a>.  Number Serialization Samples . . . . . . . . . . . .  <a href="#page-12">12</a>
   <a href="#appendix-C">Appendix C</a>.  Canonicalized JSON as "Wire Format"  . . . . . . . .  <a href="#page-13">13</a>
   <a href="#appendix-D">Appendix D</a>.  Dealing with Big Numbers . . . . . . . . . . . . . .  <a href="#page-14">14</a>
   <a href="#appendix-E">Appendix E</a>.  Implementation Guidelines  . . . . . . . . . . . . .  <a href="#page-15">15</a>
   <a href="#appendix-F">Appendix F</a>.  Open Source Implementations  . . . . . . . . . . . .  <a href="#page-16">16</a>
   <a href="#appendix-G">Appendix G</a>.  Other JSON Canonicalization Efforts  . . . . . . . .  <a href="#page-16">16</a>
   <a href="#appendix-H">Appendix H</a>.  Development Portal . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  <a href="#page-17">17</a>






<span class="grey">Rundgren, et al.          Expires July 23, 2019                 [Page 2]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-3" id="page-3" href="#page-3" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


<span class="h2"><h2><a class="selflink" name="section-1" href="#section-1">1</a>.  Introduction</h2></span>

   Cryptographic operations like hashing and signing requires that the
   target data does not change during serialization or parsing.  One way
   of accomplishing this is converting the data into a format that has a
   simple and fixed representation like Base64Url [<a href="http://tools.ietf.org/html//rfc4648" title="&quot;The Base16, Base32, and Base64 Data Encodings&quot;">RFC4648</a>], which is
   used in JWS [<a href="http://tools.ietf.org/html//rfc7515" title="&quot;JSON Web Signature (JWS)&quot;">RFC7515</a>].  Another solution is creating a canonical
   version of the data with XML Signature [<a href="#ref-XMLDSIG" title="&quot;XML Signature Syntax and Processing Version 1.1&quot;">XMLDSIG</a>] as a prime example.

   Since the objective of JCS is to keep the data "as is", the
   canonicalization method was selected.  To avoid "reinventing the
   wheel", JCS relies on serialization of JSON primitives compatible
   with ECMAScript (aka JavaScript) beginning with version 6 [<a href="#ref-ES6" title="&quot;ECMAScript 2015 Language Specification&quot;">ES6</a>], from
   now on simply referred to as "ES6".

   Seasoned XML developers recalling difficulties getting signatures to
   validate (usually due to different interpretations of the quite
   intricate XML canonicalization rules as well as of the equally
   extensive Web Services security standards), may rightfully wonder why
   JCS would not suffer from similar issues.  The reasons are twofold:

   o  The absence of a namespace concept and default values, as well as
      constraining data to the I-JSON subset eliminate the need for
      specific parsing schemes for canonicalized data.

   o  JCS compatible serialization of JSON primitives is already
      supported by most Web browsers and Node.js [<a href="#ref-NODEJS" title="&quot;Node.js&quot;">NODEJS</a>], while the
      full JCS specification is supported by multiple Open Source
      implementations (see <a href="#appendix-F">Appendix F</a>), giving the proposed
      canonicalization scheme a head start.  Also see <a href="#appendix-E">Appendix E</a>.

   The JCS specification describes how serialization of JSON primitives
   compliant with ES6, combined with an elementary property sorting
   scheme, can be used for supporting "Crypto Safe" JSON.

   JCS is compatible with some existing systems relying on JSON
   canonicalization such as JWK Thumbprint [<a href="http://tools.ietf.org/html//rfc7638" title="&quot;JSON Web Key (JWK) Thumbprint&quot;">RFC7638</a>] and Keybase
   [<a href="#ref-KEYBASE" title="&quot;Keybase&quot;">KEYBASE</a>].

<span class="h2"><h2><a class="selflink" name="section-2" href="#section-2">2</a>.  Terminology</h2></span>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in <a href="http://tools.ietf.org/html//bcp14">BCP</a>
   <a href="http://tools.ietf.org/html//bcp14">14</a> [<a href="http://tools.ietf.org/html//rfc2119" title="&quot;Key words for use in RFCs to Indicate Requirement Levels&quot;">RFC2119</a>] [<a href="http://tools.ietf.org/html//rfc8174" title="&quot;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&quot;">RFC8174</a>] when, and only when, they appear in all
   capitals, as shown here.





<span class="grey">Rundgren, et al.          Expires July 23, 2019                 [Page 3]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-4" id="page-4" href="#page-4" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


<span class="h2"><h2><a class="selflink" name="section-3" href="#section-3">3</a>.  Detailed Operation</h2></span>

   This section describes the different issues related to creating a
   canonical JSON representation, and how they are addressed by JCS.

<span class="h3"><h3><a class="selflink" name="section-3.1" href="#section-3.1">3.1</a>.  Creation of JSON Data</h3></span>

   In order to serialize JSON data, you need data that is adapted for
   JSON serialization.  This is usually achieved by:

   o  Parsing previously generated JSON data.

   o  Programmatically creating data.

   Irrespective of method used, the data to be serialized MUST be
   compatible both with ES6 and I-JSON [<a href="http://tools.ietf.org/html//rfc7493" title="&quot;The I-JSON Message Format&quot;">RFC7493</a>], which implies the
   following:

   o  There MUST NOT be any duplicate property names within an element
      to be serialized as a JSON Object.

   o  String data MUST be expressible as Unicode [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>].  Also see
      <a href="#section-3.2.2.2">Section 3.2.2.2</a>.

   o  Numeric data MUST be expressible as IEEE-754 [<a href="#ref-IEEE754" title="&quot;IEEE Standard for Floating-Point Arithmetic&quot;">IEEE754</a>] double
      precision values.  Also see <a href="#section-3.2.2.3">Section 3.2.2.3</a>.

<span class="h3"><h3><a class="selflink" name="section-3.2" href="#section-3.2">3.2</a>.  Canonicalization of JSON Data</h3></span>

   The following subsections describe the steps required for creating a
   canonical JSON representation of the data elaborated on in the
   previous section.

   <a href="#appendix-A">Appendix A</a> shows sample code for an ES6 based canonicalizer, matching
   the JCS specification.

<span class="h4"><h4><a class="selflink" name="section-3.2.1" href="#section-3.2.1">3.2.1</a>.  Whitespace Handling</h4></span>

   Whitespace between JSON elements MUST NOT be emitted.

<span class="h4"><h4><a class="selflink" name="section-3.2.2" href="#section-3.2.2">3.2.2</a>.  Serialization of Primitive Data Types</h4></span>

   Assume that you parse a JSON object like the following:








<span class="grey">Rundgren, et al.          Expires July 23, 2019                 [Page 4]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-5" id="page-5" href="#page-5" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


     {
       "numbers": [333333333.33333329, 1E30, 4.50,
                   2e-3, 0.000000000000000000000000001],
       "string": "\u20ac$\u000F\u000aA'\u0042\u0022\u005c\\\"\/",
       "literals": [null, true, false]
     }

   If you subsequently serialize the parsed data using a serializer
   compliant with ES6's "JSON.stringify()", the result would (with a
   line wrap added for display purposes only), be rather divergent with
   respect to representation of data:

     {"numbers":[333333333.3333333,1e+30,4.5,0.002,1e-27],"string":
     "\u20ac$\u000f\nA'B\"\\\\\"/","literals":[null,true,false]}

      Note: \u20ac denotes the Euro character, which not
      being ASCII, is currently not displayable in RFCs.

   The reason for the difference between the parsed data and its
   serialized counterpart, is due to a wide tolerance on input data (as
   defined by JSON [<a href="http://tools.ietf.org/html//rfc8259" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC8259</a>]), while output data (as defined by ES6),
   has a fixed representation.  As can be seen by the example, numbers
   are subject to rounding as well.

   The following subsections describe serialization of primitive JSON
   data types according to JCS.  This part is identical to that of ES6.

<span class="h5"><h5><a class="selflink" name="section-3.2.2.1" href="#section-3.2.2.1">3.2.2.1</a>.  Serialization of Literals</h5></span>

   The JSON literals "null", "true", and "false" present no challenge
   since they already have a fixed definition in JSON [<a href="http://tools.ietf.org/html//rfc8259" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC8259</a>].

<span class="h5"><h5><a class="selflink" name="section-3.2.2.2" href="#section-3.2.2.2">3.2.2.2</a>.  Serialization of Strings</h5></span>

   For JSON String data (which includes JSON Object property names as
   well), each character MUST be serialized as described below (also
   matching <a href="#section-24.3.2.2">section 24.3.2.2</a> of ES6):

   o  If the Unicode value falls within the traditional ASCII control
      character range (U+0000 through U+001F), it MUST be serialized
      using lowercase hexadecimal Unicode notation (\uhhhh) unless it is
      in the set of predefined JSON control characters U+0008, U+0009,
      U+000A, U+000C or U+000D which MUST be serialized as \b, \t, \n,
      \f and \r respectively.

   o  If the Unicode value is outside of the ASCII control character
      range, it MUST be serialized "as is" unless it is equivalent to




<span class="grey">Rundgren, et al.          Expires July 23, 2019                 [Page 5]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-6" id="page-6" href="#page-6" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


      U+005C (\) or U+0022 (") which MUST be serialized as \\ and \"
      respectively.

   Finally, the serialized string value MUST be enclosed in double
   quotes (").

   Note: some JSON systems permit the use of invalid Unicode data like
   "lone surrogates" (e.g.  U+DEAD), which also is dealt with in a
   platform specific way.  Since this leads to interoperability issues
   including broken signatures, such usages MUST be avoided.

   Note: although the Unicode standard offers a possibility combining
   certain characters into one, referred to as "Unicode Normalization"
   (<a href="https://www.unicode.org/reports/tr15/">https://www.unicode.org/reports/tr15/</a> [<a href="#ref-1">1</a>]), such functionality MUST
   be delegated to the application layer.

<span class="h5"><h5><a class="selflink" name="section-3.2.2.3" href="#section-3.2.2.3">3.2.2.3</a>.  Serialization of Numbers</h5></span>

   JSON data of the type Number MUST be serialized according to <a href="#section-7.1.12.1">section</a>
   <a href="#section-7.1.12.1">7.1.12.1</a> of ES6 including the "Note 2" enhancement.

   Due to the relative complexity of this part, the algorithm itself is
   not included in this document.  However, the specification is fully
   implemented by for example Google's V8 [<a href="#ref-V8" title="&quot;Chrome V8 Open Source JavaScript Engine&quot;">V8</a>].  The open source Java
   implementation mentioned in <a href="#appendix-F">Appendix F</a> uses a recently developed
   number serialization algorithm called Ryu [<a href="#ref-RYU" title="&quot;Ryu floating point number serializing algorithm&quot;">RYU</a>].

   ES6 builds on the IEEE-754 [<a href="#ref-IEEE754" title="&quot;IEEE Standard for Floating-Point Arithmetic&quot;">IEEE754</a>] double precision standard for
   representing JSON Number data.  <a href="#appendix-B">Appendix B</a> holds a set of IEEE-754
   sample values and their corresponding JSON serialization.

   Occasionally applications need higher precision or longer integers
   than offered by IEEE-754 double precision.  <a href="#appendix-D">Appendix D</a> outlines how
   this can be achieved in a portable and extensible way.

<span class="h4"><h4><a class="selflink" name="section-3.2.3" href="#section-3.2.3">3.2.3</a>.  Sorting of Object Properties</h4></span>

   Although the previous step indeed normalized the representation of
   primitive JSON data types, the result would not qualify as canonical
   since JSON Object properties are not in lexicographic (alphabetical)
   order.

   Applied to the sample in <a href="#section-3.2.2">Section 3.2.2</a>, a properly canonicalized
   version should (with a line wrap added for display purposes only),
   read as:

     {"literals":[null,true,false],"numbers":[333333333.3333333,
     1e+30,4.5,0.002,1e-27],"string":"\u20ac$\u000f\nA'B\"\\\\\"/"}



<span class="grey">Rundgren, et al.          Expires July 23, 2019                 [Page 6]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-7" id="page-7" href="#page-7" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


      Note: \u20ac denotes the Euro character, which not
      being ASCII, is currently not displayable in RFCs.

   The rules for lexicographic sorting of JSON Object properties
   according to JCS are as follows:

   o  JSON Object properties MUST be sorted in a recursive manner which
      means that possible JSON child Objects MUST have their properties
      sorted as well.

   o  JSON Array data MUST also be scanned for presence of JSON Objects
      (and applying associated property sorting), but array element
      order MUST NOT be changed.

   When a JSON Object is about to have its properties sorted, the
   following measures MUST be adhered to:

   o  The sorting process is applied to property strings in their "raw"
      (unescaped) form.  That is, a newline character is treated as
      U+000A.

   o  Property strings to be sorted are formatted as arrays of UTF-16
      [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>] code units.  The sorting is based on pure value
      comparisons, where code units are treated as unsigned integers,
      independent of locale settings.

   o  Property strings either have different values at some index that
      is a valid index for both strings, or their lengths are different,
      or both.  If they have different values at one or more index
      positions, let k be the smallest such index; then the string whose
      value at position k has the smaller value, as determined by using
      the &lt; operator, lexicographically precedes the other string.  If
      there is no index position at which they differ, then the shorter
      string lexicographically precedes the longer string.

      In plain english this means that property names are sorted in
      ascending order like the following:

           ""
           "a"
           "aa"
           "ab"

   The rationale for basing the sort algorithm on UTF-16 code units is
   that it maps directly to the string type in ECMAScript, Java and
   .NET.  Systems using another internal representation of string data
   will need to convert JSON property strings into arrays of UTF-16 code




<span class="grey">Rundgren, et al.          Expires July 23, 2019                 [Page 7]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-8" id="page-8" href="#page-8" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


   units before sorting.  The conversion from UTF-8 or UTF-32 to UTF-16
   is defined by the Unicode [<a href="#ref-UNICODE" title="&quot;The Unicode Standard, Version 10.0.0&quot;">UNICODE</a>] standard.

   Note: for the purpose of obtaining a deterministic property order,
   sorting on UTF-8 or UTF-32 encoded data would also work, but the
   result would differ (and thus be incompatible with this
   specification).

<span class="h4"><h4><a class="selflink" name="section-3.2.4" href="#section-3.2.4">3.2.4</a>.  UTF-8 Generation</h4></span>

   Finally, in order to create a platform independent representation,
   the resulting JSON string data MUST be encoded in UTF-8.

   Applied to the sample in <a href="#section-3.2.3">Section 3.2.3</a> this should yield the
   following bytes here shown in hexadecimal notation:

     7b 22 6c 69 74 65 72 61 6c 73 22 3a 5b 6e 75 6c 6c 2c 74 72
     75 65 2c 66 61 6c 73 65 5d 2c 22 6e 75 6d 62 65 72 73 22 3a
     5b 33 33 33 33 33 33 33 33 33 2e 33 33 33 33 33 33 33 2c 31
     65 2b 33 30 2c 34 2e 35 2c 30 2e 30 30 32 2c 31 65 2d 32 37
     5d 2c 22 73 74 72 69 6e 67 22 3a 22 e2 82 ac 24 5c 75 30 30
     30 66 5c 6e 41 27 42 5c 22 5c 5c 5c 5c 5c 22 2f 22 7d

   This data is intended to be usable as input to cryptographic methods
   as well as for value comparisons of JSON objects.

   For other uses see <a href="#appendix-C">Appendix C</a>.

<span class="h2"><h2><a class="selflink" name="section-4" href="#section-4">4</a>.  IANA Considerations</h2></span>

   This document has no IANA actions.

<span class="h2"><h2><a class="selflink" name="section-5" href="#section-5">5</a>.  Security Considerations</h2></span>

   It is vital performing "sanity" checks on input data to avoid
   overflowing buffers and similar things that could affect the
   integrity of the system.

<span class="h2"><h2><a class="selflink" name="section-6" href="#section-6">6</a>.  Acknowledgements</h2></span>

   Building on ES6 Number serialization was originally proposed by James
   Manger.  This ultimately led to the adoption of the entire ES6
   serialization scheme for JSON primitives.

   Other people who have contributed with valuable input to this
   specification include Bron Gondwana, John-Mark Gurney, Mike Jones,
   Mike Miller, Mike Samuel, Michal Wadas, Richard Gibson, Robert
   Tupelo-Schneck and Scott Ananian.



<span class="grey">Rundgren, et al.          Expires July 23, 2019                 [Page 8]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-9" id="page-9" href="#page-9" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


<span class="h2"><h2><a class="selflink" name="section-7" href="#section-7">7</a>.  References</h2></span>

<span class="h3"><h3><a class="selflink" name="section-7.1" href="#section-7.1">7.1</a>.  Normative References</h3></span>

   [<a name="ref-ES6" id="ref-ES6">ES6</a>]      Ecma International, "ECMAScript 2015 Language
              Specification", &lt;<a href="https://www.ecma-international.org/ecma-262/6.0/index.html">https://www.ecma-international.org/ecma-</a>
              <a href="https://www.ecma-international.org/ecma-262/6.0/index.html">262/6.0/index.html</a>&gt;.

   [<a name="ref-IEEE754" id="ref-IEEE754">IEEE754</a>]  IEEE, "IEEE Standard for Floating-Point Arithmetic",
              August 2008, &lt;<a href="http://grouper.ieee.org/groups/754/">http://grouper.ieee.org/groups/754/</a>&gt;.

   [<a name="ref-RFC2119" id="ref-RFC2119">RFC2119</a>]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", <a href="http://tools.ietf.org/html//bcp14">BCP 14</a>, <a href="http://tools.ietf.org/html//rfc2119">RFC 2119</a>,
              DOI 10.17487/RFC2119, March 1997,
              &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.

   [<a name="ref-RFC7493" id="ref-RFC7493">RFC7493</a>]  Bray, T., Ed., "The I-JSON Message Format", <a href="http://tools.ietf.org/html//rfc7493">RFC 7493</a>,
              DOI 10.17487/RFC7493, March 2015,
              &lt;<a href="https://www.rfc-editor.org/info/rfc7493">https://www.rfc-editor.org/info/rfc7493</a>&gt;.

   [<a name="ref-RFC8174" id="ref-RFC8174">RFC8174</a>]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in <a href="http://tools.ietf.org/html//rfc2119">RFC</a>
              <a href="http://tools.ietf.org/html//rfc2119">2119</a> Key Words", <a href="http://tools.ietf.org/html//bcp14">BCP 14</a>, <a href="http://tools.ietf.org/html//rfc8174">RFC 8174</a>, DOI 10.17487/RFC8174,
              May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.

   [<a name="ref-RFC8259" id="ref-RFC8259">RFC8259</a>]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, <a href="http://tools.ietf.org/html//rfc8259">RFC 8259</a>,
              DOI 10.17487/RFC8259, December 2017,
              &lt;<a href="https://www.rfc-editor.org/info/rfc8259">https://www.rfc-editor.org/info/rfc8259</a>&gt;.

   [<a name="ref-UNICODE" id="ref-UNICODE">UNICODE</a>]  The Unicode Consortium, "The Unicode Standard, Version
              10.0.0",
              &lt;<a href="https://www.unicode.org/versions/Unicode10.0.0/">https://www.unicode.org/versions/Unicode10.0.0/</a>&gt;.

<span class="h3"><h3><a class="selflink" name="section-7.2" href="#section-7.2">7.2</a>.  Informal References</h3></span>

   [<a name="ref-KEYBASE" id="ref-KEYBASE">KEYBASE</a>]  "Keybase",
              &lt;<a href="https://keybase.io/docs/api/1.0/canonical_packings#json">https://keybase.io/docs/api/1.0/canonical_packings#json</a>&gt;.

   [<a name="ref-NODEJS" id="ref-NODEJS">NODEJS</a>]   "Node.js", &lt;<a href="https://nodejs.org/">https://nodejs.org</a>&gt;.

   [<a name="ref-OPENAPI" id="ref-OPENAPI">OPENAPI</a>]  "The OpenAPI Initiative", &lt;<a href="https://www.openapis.org/">https://www.openapis.org/</a>&gt;.

   [<a name="ref-RFC4648" id="ref-RFC4648">RFC4648</a>]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", <a href="http://tools.ietf.org/html//rfc4648">RFC 4648</a>, DOI 10.17487/RFC4648, October 2006,
              &lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;.






<span class="grey">Rundgren, et al.          Expires July 23, 2019                 [Page 9]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-10" id="page-10" href="#page-10" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


   [<a name="ref-RFC7515" id="ref-RFC7515">RFC7515</a>]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", <a href="http://tools.ietf.org/html//rfc7515">RFC 7515</a>, DOI 10.17487/RFC7515, May
              2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7515">https://www.rfc-editor.org/info/rfc7515</a>&gt;.

   [<a name="ref-RFC7638" id="ref-RFC7638">RFC7638</a>]  Jones, M. and N. Sakimura, "JSON Web Key (JWK)
              Thumbprint", <a href="http://tools.ietf.org/html//rfc7638">RFC 7638</a>, DOI 10.17487/RFC7638, September
              2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7638">https://www.rfc-editor.org/info/rfc7638</a>&gt;.

   [<a name="ref-RYU" id="ref-RYU">RYU</a>]      Google LLC, "Ryu floating point number serializing
              algorithm", &lt;<a href="https://github.com/ulfjack/ryu">https://github.com/ulfjack/ryu</a>&gt;.

   [<a name="ref-V8" id="ref-V8">V8</a>]       Google LLC, "Chrome V8 Open Source JavaScript Engine",
              &lt;<a href="https://developers.google.com/v8/">https://developers.google.com/v8/</a>&gt;.

   [<a name="ref-XMLDSIG" id="ref-XMLDSIG">XMLDSIG</a>]  W3C, "XML Signature Syntax and Processing Version 1.1",
              &lt;<a href="https://www.w3.org/TR/xmldsig-core1/">https://www.w3.org/TR/xmldsig-core1/</a>&gt;.

<span class="h3"><h3><a class="selflink" name="section-7.3" href="#section-7.3">7.3</a>.  URIs</h3></span>

   [<a name="ref-1" id="ref-1">1</a>] <a href="https://www.unicode.org/reports/tr15/">https://www.unicode.org/reports/tr15/</a>

   [<a name="ref-2" id="ref-2">2</a>] <a href="https://www.npmjs.com/package/canonicalize">https://www.npmjs.com/package/canonicalize</a>

   [<a name="ref-3" id="ref-3">3</a>] <a href="https://github.com/erdtman/java-json-canonicalization">https://github.com/erdtman/java-json-canonicalization</a>

   [<a name="ref-4" id="ref-4">4</a>] <a href="https://github.com/cyberphone/json-canonicalization/tree/master/go">https://github.com/cyberphone/json-canonicalization/tree/master/</a>
       <a href="https://github.com/cyberphone/json-canonicalization/tree/master/go">go</a>

   [<a name="ref-5" id="ref-5">5</a>] <a href="https://github.com/cyberphone/json-canonicalization/tree/master/dotnet">https://github.com/cyberphone/json-canonicalization/tree/master/</a>
       <a href="https://github.com/cyberphone/json-canonicalization/tree/master/dotnet">dotnet</a>

   [<a name="ref-6" id="ref-6">6</a>] <a href="https://github.com/cyberphone/json-canonicalization/tree/master/python3">https://github.com/cyberphone/json-canonicalization/tree/master/</a>
       <a href="https://github.com/cyberphone/json-canonicalization/tree/master/python3">python3</a>

   [<a name="ref-7" id="ref-7">7</a>] <a href="https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00">https://tools.ietf.org/html/draft-staykov-hu-json-canonical-</a>
       <a href="https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00">form-00</a>

   [<a name="ref-8" id="ref-8">8</a>] <a href="https://gibson042.github.io/canonicaljson-spec/">https://gibson042.github.io/canonicaljson-spec/</a>

   [<a name="ref-9" id="ref-9">9</a>] <a href="http://wiki.laptop.org/go/Canonical_JSON">http://wiki.laptop.org/go/Canonical_JSON</a>

   [<a name="ref-10" id="ref-10">10</a>] <a href="https://github.com/cyberphone/json-canonicalization">https://github.com/cyberphone/json-canonicalization</a>

<span class="h2"><h2><a class="selflink" name="appendix-A" href="#appendix-A">Appendix A</a>.  ES6 Sample Canonicalizer</h2></span>

   Below is a functionally complete example of a JCS compliant
   canonicalizer for usage with ES6 based systems.




<span class="grey">Rundgren, et al.          Expires July 23, 2019                [Page 10]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-11" id="page-11" href="#page-11" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


   Note: the primary purpose of this code is highlighting the
   canonicalization algorithm.  Using the full power of ES6 would reduce
   the code size considerably but would also be more difficult to follow
   by non-experts.

     var canonicalize = function(object) {

         var buffer = '';
         serialize(object);
         return buffer;

         function serialize(object) {
             if (object === null || typeof object !== 'object') {
                 /////////////////////////////////////////////////
                 // Primitive data type - Use ES6/JSON          //
                 /////////////////////////////////////////////////
                 buffer += JSON.stringify(object);

             } else if (Array.isArray(object)) {
                 /////////////////////////////////////////////////
                 // Array - Maintain element order              //
                 /////////////////////////////////////////////////
                 buffer += '[';
                 let next = false;
                 object.forEach((element) =&gt; {
                     if (next) {
                         buffer += ',';
                     }
                     next = true;
                     /////////////////////////////////////////
                     // Array element - Recursive expansion //
                     /////////////////////////////////////////
                     serialize(element);
                 });
                 buffer += ']';

             } else {
                 /////////////////////////////////////////////////
                 // Object - Sort properties before serializing //
                 /////////////////////////////////////////////////
                 buffer += '{';
                 let next = false;
                 Object.keys(object).sort().forEach((property) =&gt; {
                     if (next) {
                         buffer += ',';
                     }
                     next = true;
                     ///////////////////////////////////////////////



<span class="grey">Rundgren, et al.          Expires July 23, 2019                [Page 11]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-12" id="page-12" href="#page-12" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


                     // Property names are strings - Use ES6/JSON //
                     ///////////////////////////////////////////////
                     buffer += JSON.stringify(property);
                     buffer += ':';
                     //////////////////////////////////////////
                     // Property value - Recursive expansion //
                     //////////////////////////////////////////
                     serialize(object[property]);
                 });
                 buffer += '}';
             }
         }
     };

<span class="h2"><h2><a class="selflink" name="appendix-B" href="#appendix-B">Appendix B</a>.  Number Serialization Samples</h2></span>

   The following table holds a set of ES6 compatible Number
   serialization samples, including some edge cases.  The column "IEEE-
   754" refers to the internal ES6 representation of the Number data
   type which is based on the IEEE-754 [<a href="#ref-IEEE754" title="&quot;IEEE Standard for Floating-Point Arithmetic&quot;">IEEE754</a>] standard using 64-bit
   (double precision) values, here expressed in hexadecimal.

  |====================================================================|
  |     IEEE-754     |   JSON Representation     |       Comment       |
  |====================================================================|
  | 0000000000000000 | 0                         | Zero                |
  |--------------------------------------------------------------------|
  | 8000000000000000 | 0                         | Minus zero          |
  |--------------------------------------------------------------------|
  | 0000000000000001 | 5e-324                    | Smallest pos number |
  |--------------------------------------------------------------------|
  | 8000000000000001 | -5e-324                   | Smallest neg number |
  |--------------------------------------------------------------------|
  | 7fefffffffffffff | 1.7976931348623157e+308   | Largest pos number  |
  |--------------------------------------------------------------------|
  | ffefffffffffffff | -1.7976931348623157e+308  | Largest neg number  |
  |--------------------------------------------------------------------|
  | 4340000000000000 | 9007199254740992          | Largest pos integer |
  |--------------------------------------------------------------------|
  | c340000000000000 | -9007199254740992         | Largest neg integer |
  |--------------------------------------------------------------------|
  | 7fffffffffffffff |                           | Error (NaN)         |
  |--------------------------------------------------------------------|
  | 7ff0000000000000 |                           | Error (Infinity)    |
  |--------------------------------------------------------------------|
  | 44b52d02c7e14af5 | 9.999999999999997e+22     |                     |
  |--------------------------------------------------------------------|
  | 44b52d02c7e14af6 | 1e+23                     |                     |



<span class="grey">Rundgren, et al.          Expires July 23, 2019                [Page 12]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-13" id="page-13" href="#page-13" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


  |--------------------------------------------------------------------|
  | 44b52d02c7e14af7 | 1.0000000000000001e+23    |                     |
  |--------------------------------------------------------------------|
  | 444b1ae4d6e2ef4e | 999999999999999700000     |                     |
  |--------------------------------------------------------------------|
  | 444b1ae4d6e2ef4f | 999999999999999900000     |                     |
  |--------------------------------------------------------------------|
  | 3eb0c6f7a0b5ed8d | 0.000001                  |                     |
  |--------------------------------------------------------------------|
  | 3eb0c6f7a0b5ed8c | 9.999999999999997e-7      |                     |
  |--------------------------------------------------------------------|
  | 41b3de4355555553 | 333333333.3333332         |                     |
  |--------------------------------------------------------------------|
  | 41b3de4355555554 | 333333333.33333325        |                     |
  |--------------------------------------------------------------------|
  | 41b3de4355555555 | 333333333.3333333         |                     |
  |--------------------------------------------------------------------|
  | 41b3de4355555556 | 333333333.3333334         |                     |
  |--------------------------------------------------------------------|
  | 41b3de4355555557 | 333333333.33333343        |                     |
  |--------------------------------------------------------------------|
  | becbf647612f3696 | -0.0000033333333333333333 |                     |
  |--------------------------------------------------------------------|

   Note: for maximum compliance with ECMAScript's "JSON" object, values
   that are to be interpreted as true integers, SHOULD be in the range
   -9007199254740991 to 9007199254740991.

   Note: although a set of specific integers like 2**68
   (4430000000000000 in IEEE-754 format) could be regarded as having
   extended precision, the JCS/ES6 number serialization algorithm does
   not take this in consideration.

<span class="h2"><h2><a class="selflink" name="appendix-C" href="#appendix-C">Appendix C</a>.  Canonicalized JSON as "Wire Format"</h2></span>

   Since the result from the canonicalization process (see
   <a href="#section-3.2.4">Section 3.2.4</a>), is fully valid JSON, it can also be used as
   "Wire Format".  However, this is just an option since cryptographic
   schemes based on JCS, in most cases would not depend on that
   externally supplied JSON data already is canonicalized.

   In fact, the ES6 standard way of serializing objects using
   "JSON.stringify()" produces a more "logical" format, where properties
   are kept in the order they were created or received.  The example
   below shows an address record which could benefit from ES6 standard
   serialization:





<span class="grey">Rundgren, et al.          Expires July 23, 2019                [Page 13]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-14" id="page-14" href="#page-14" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


     {
       "name": "John Doe",
       "address": "2000 Sunset Boulevard",
       "city": "Los Angeles",
       "zip": "90001",
       "state": "CA"
     }

   Using canonicalization the properties above would be output in the
   order "address", "city", "name", "state" and "zip", which adds
   fuzziness to the data from a human (developer or technical support),
   perspective.

   That is, for many applications, canonicalization would only be used
   internally for creating a "hashable" representation of the data
   needed for cryptographic operations.

   Note: if message size is not a concern, you may even send
   "Pretty Printed" JSON data on the wire (since whitespace always is
   ignored by the canonicalization process).

<span class="h2"><h2><a class="selflink" name="appendix-D" href="#appendix-D">Appendix D</a>.  Dealing with Big Numbers</h2></span>

   There are two major issues associated with the JSON Number type, here
   illustrated by the following sample object:

     {
       "giantNumber": 1.4e+9999,
       "payMeThis": 26000.33,
       "int64Max": 9223372036854775807
     }

   Although the sample above conforms to JSON (according to [<a href="http://tools.ietf.org/html//rfc8259" title="&quot;The JavaScript Object Notation (JSON) Data Interchange Format&quot;">RFC8259</a>]),
   there are some practical hurdles to consider:

   o  Standard JSON parsers rarely process "giantNumber" in a meaningful
      way.  64-bit integers like "int64Max" normally pass through
      parsers, but in systems like ES6, at the expense of lost
      precision.

   o  Another issue is that parsers typically would use different
      schemes for handling "giantNumber" and "int64Max".  In addition,
      monetary data like "payMeThis" would presumably not rely on a
      floating point system due to rounding issues with respect to
      decimal arithmetic.

      The (to the author NB), only known way handling this kind of
      "overloading" of the JSON Number type (at least in an extensible



<span class="grey">Rundgren, et al.          Expires July 23, 2019                [Page 14]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-15" id="page-15" href="#page-15" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


      manner), is through mapping mechanisms, instructing parsers what
      to do with different properties based on their name.  However,
      this greatly limits the value of using the Number type outside of
      its original somewhat constrained, JavaScript context.

   For usage with JCS (and in fact for any usage of JSON by multiple
   parties potentially using independently developed software), numbers
   that do not have a natural place in the current JSON ecosystem MUST
   be wrapped using the JSON String type.  This is close to a de-facto
   standard for open systems.

   Aided by a mapping system; be it programmatic like

     var obj = JSON.parse('{"giantNumber": "1.4e+9999"}');
     var biggie = new BigNumber(obj.giantNumber);

   or declarative schemes like OpenAPI [<a href="#ref-OPENAPI" title="&quot;The OpenAPI Initiative&quot;">OPENAPI</a>], there are no real
   limits, not even when using ES6.

<span class="h2"><h2><a class="selflink" name="appendix-E" href="#appendix-E">Appendix E</a>.  Implementation Guidelines</h2></span>

   The optimal solution is integrating support for JCS directly in JSON
   serializers (parsers need no changes).  That is, canonicalization
   would just be an additional "mode" for a JSON serializer.  However,
   this is currently not the case.  Fortunately JCS support can be
   performed through externally supplied canonicalizer software,
   enabling signature creation schemes like the following:

   1.  Create the data to be signed.

   2.  Serialize the data using existing JSON tools.

   3.  Let the external canonicalizer process the serialized data and
       return canonicalized result data.

   4.  Sign the canonicalized data.

   5.  Add the resulting signature value to the original JSON data
       through a designated signature property.

   6.  Serialize the completed (now signed) JSON object using existing
       JSON tools.

   A compatible signature verification scheme would then be as follows:

   1.  Parse the signed JSON data using existing JSON tools.





<span class="grey">Rundgren, et al.          Expires July 23, 2019                [Page 15]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-16" id="page-16" href="#page-16" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


   2.  Read and save the signature value from the designated signature
       property.

   3.  Remove the signature property from the parsed JSON object.

   4.  Serialize the remaining JSON data using existing JSON tools.

   5.  Let the external canonicalizer process the serialized data and
       return canonicalized result data.

   6.  Verify that the canonicalized data matches the saved signature
       value using the algorithm and key used for creating the
       signature.

   A canonicalizer like above is effectively only a "filter",
   potentially usable with a multitude of quite different cryptographic
   schemes.

   Using a JSON serializer with integrated JCS support, the
   serialization performed before the canonicalization step could be
   eliminated for both processes.

<span class="h2"><h2><a class="selflink" name="appendix-F" href="#appendix-F">Appendix F</a>.  Open Source Implementations</h2></span>

   The following Open Source implementations have been verified to be
   compatible with JCS:

   o  JavaScript: <a href="https://www.npmjs.com/package/canonicalize">https://www.npmjs.com/package/canonicalize</a> [<a href="#ref-2">2</a>]

   o  Java: <a href="https://github.com/erdtman/java-json-canonicalization">https://github.com/erdtman/java-json-canonicalization</a> [<a href="#ref-3">3</a>]

   o  Go: <a href="https://github.com/cyberphone/json-canonicalization/tree/master/go">https://github.com/cyberphone/json-</a>
      <a href="https://github.com/cyberphone/json-canonicalization/tree/master/go">canonicalization/tree/master/go</a> [<a href="#ref-4">4</a>]

   o  .NET/C#: <a href="https://github.com/cyberphone/json-canonicalization/tree/master/dotnet">https://github.com/cyberphone/json-</a>
      <a href="https://github.com/cyberphone/json-canonicalization/tree/master/dotnet">canonicalization/tree/master/dotnet</a> [<a href="#ref-5">5</a>]

   o  Python: <a href="https://github.com/cyberphone/json-canonicalization/tree/master/python3">https://github.com/cyberphone/json-</a>
      <a href="https://github.com/cyberphone/json-canonicalization/tree/master/python3">canonicalization/tree/master/python3</a> [<a href="#ref-6">6</a>]

<span class="h2"><h2><a class="selflink" name="appendix-G" href="#appendix-G">Appendix G</a>.  Other JSON Canonicalization Efforts</h2></span>

   There are (and have been) other efforts creating "Canonical JSON".
   Below is a list of URLs to some of them:

   o  <a href="https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00">https://tools.ietf.org/html/draft-staykov-hu-json-canonical-</a>
      <a href="https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00">form-00</a> [<a href="#ref-7">7</a>]




<span class="grey">Rundgren, et al.          Expires July 23, 2019                [Page 16]</span></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre class="newpage"><a name="page-17" id="page-17" href="#page-17" class="invisible"> </a>
<span class="grey">Internet-Draft <a href="http://tools.ietf.org/html//draft-rundgren-json-canonicalization-scheme">draft-rundgren-json-canonicalization-scheme</a>  January 2019</span>


   o  <a href="https://gibson042.github.io/canonicaljson-spec/">https://gibson042.github.io/canonicaljson-spec/</a> [<a href="#ref-8">8</a>]

   o  <a href="http://wiki.laptop.org/go/Canonical_JSON">http://wiki.laptop.org/go/Canonical_JSON</a> [<a href="#ref-9">9</a>]

<span class="h2"><h2><a class="selflink" name="appendix-H" href="#appendix-H">Appendix H</a>.  Development Portal</h2></span>

   The JSC specification is currently developed at
   <a href="https://github.com/cyberphone/json-canonicalization">https://github.com/cyberphone/json-canonicalization</a> [<a href="#ref-10">10</a>].

   The portal also provides software for on-line testing as well as test
   data for implementers.

Authors' Addresses

   Anders Rundgren
   Independent
   Montpellier
   France

   Email: anders.rundgren.net@gmail.com
   URI:   <a href="https://www.linkedin.com/in/andersrundgren/">https://www.linkedin.com/in/andersrundgren/</a>


   Bret Jordan
   Symantec Corporation
   350 Ellis Street
   Mountain View  CA 94043
   USA

   Email: bret_jordan@symantec.com


   Samuel Erdtman
   Spotify AB
   Birger Jarlsgatan 61, 4tr
   Stockholm  113 56
   Sweden

   Email: erdtman@spotify.com












Rundgren, et al.          Expires July 23, 2019                [Page 17]

</pre><br>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129b, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>


</body></html>