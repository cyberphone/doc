<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">

  <title>JSON Canonicalization Scheme (JCS) </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/

  
.tftable {border-collapse: collapse}
.tftable th {font-size:10pt;background-color: #f0f0f0;
border-width:1px;padding:4pt 10pt 4pt 10pt;
border-style:solid;border-color: #a9a9a9;text-align:center;font-family:arial,verdana,helvetica}
.tftable tr {background-color:#FFFFE0}
.tftable td {border-width:1px;padding:4pt 8pt 4pt 8pt;border-style:solid;border-color:#a9a9a9}
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: #f0f0f0;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Detailed Operation">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Creation of JSON Data">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Canonicalization of JSON Data">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Whitespace Handling">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Serialization of Primitive Data Types">
<link href="#rfc.section.3.2.2.1" rel="Chapter" title="3.2.2.1 Serialization of Literals">
<link href="#rfc.section.3.2.2.2" rel="Chapter" title="3.2.2.2 Serialization of Strings">
<link href="#rfc.section.3.2.2.3" rel="Chapter" title="3.2.2.3 Serialization of Numbers">
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 Sorting of Object Properties">
<link href="#rfc.section.3.2.4" rel="Chapter" title="3.2.4 UTF-8 Generation">
<link href="#rfc.section.4" rel="Chapter" title="4 IANA Considerations">
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="7 References">
<link href="#rfc.references.1" rel="Chapter" title="7.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="7.2 Informal References">
<link href="#rfc.appendix.A" rel="Chapter" title="A ES6 Sample Canonicalizer">
<link href="#rfc.appendix.B" rel="Chapter" title="B Number Serialization Samples">
<link href="#rfc.appendix.C" rel="Chapter" title="C Canonicalized JSON as &quot;Wire Format&quot;">
<link href="#rfc.appendix.D" rel="Chapter" title="D Dealing with Big Numbers">
<link href="#rfc.appendix.E" rel="Chapter" title="E Other JSON Canonicalization Efforts">
<link href="#rfc.appendix.F" rel="Chapter" title="F Development Portal">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.6 - https://tools.ietf.org/tools/xml2rfc">
  <link rel="schema.dct" href="http://purl.org/dc/terms/">

  <meta name="dct.creator" content="Rundgren, A.">
  <meta name="dct.identifier" content="urn:ietf:id:draft-rundgren-json-canonicalization-scheme-00">
  <meta name="dct.issued" scheme="ISO8601" content="2018-30">
  <meta name="dct.abstract" content="Cryptographic operations like hashing and signing depend on that the target data does not change during serialization, transport, or parsing.  By applying the rules defined by JCS (JSON Canonicalization Scheme), data provided in the JSON ">
  <meta name="description" content="Cryptographic operations like hashing and signing depend on that the target data does not change during serialization, transport, or parsing.  By applying the rules defined by JCS (JSON Canonicalization Scheme), data provided in the JSON ">

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">A. Rundgren</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Independent</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">April 30, 2018</td>
</tr>
<tr>
<td class="left">Expires: November 1, 2018</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">JSON Canonicalization Scheme (JCS) <br>
  <span class="filename">draft-rundgren-json-canonicalization-scheme-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Cryptographic operations like hashing and signing depend on that the 
target data does not change during serialization, transport, or parsing.
  By applying the rules defined by JCS (JSON Canonicalization Scheme), 
data provided in the JSON <a href="#RFC8259" class="xref">[RFC8259]</a> 
format can be exchanged "as is", while still being subject to secure 
cryptographic operations.  JCS achieves this by combining the strict 
serialization of JSON data defined in ECMAScript <a href="#ES6" class="xref">[ES6]</a> with a platform independent sorting scheme.  </p>
<p>The intended audiences of this document are JSON tool vendors, as well as designers of JSON based cryptographic solutions.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering 
Task Force (IETF).  Note that other groups may also distribute working 
documents as Internet-Drafts.  The list of current Internet-Drafts is at
 https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months
 and may be updated, replaced, or obsoleted by other documents at any 
time.  It is inappropriate to use Internet-Drafts as reference material 
or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on November 1, 2018.</p><p><i>Note: this document has been slightly "enhanced" to make it more readable.</i></p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal 
Provisions Relating to IETF Documents 
(https://trustee.ietf.org/license-info) in effect on the date of 
publication of this document.  Please review these documents carefully, 
as they describe your rights and restrictions with respect to this 
document.  Code Components extracted from this document must include 
Simplified BSD License text as described in Section 4.e of the Trust 
Legal Provisions and are provided without warranty as described in the 
Simplified BSD License.</p>

  
  <hr class="noprint">
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li >2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li >3.   <a href="#rfc.section.3">Detailed Operation</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Creation of JSON Data</a>
</li>
<li >3.2.   <a href="#rfc.section.3.2">Canonicalization of JSON Data</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Whitespace Handling</a>
</li>
<li >3.2.2.   <a href="#rfc.section.3.2.2">Serialization of Primitive Data Types</a>
</li>
<ul><li>3.2.2.1.   <a href="#rfc.section.3.2.2.1">Serialization of Literals</a>
</li>
<li >3.2.2.2.   <a href="#rfc.section.3.2.2.2">Serialization of Strings</a>
</li>
<li >3.2.2.3.   <a href="#rfc.section.3.2.2.3">Serialization of Numbers</a>
</li>
</ul><li>3.2.3.   <a href="#rfc.section.3.2.3">Sorting of Object Properties</a>
</li>
<li >3.2.4.   <a href="#rfc.section.3.2.4">UTF-8 Generation</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">IANA Considerations</a>
</li>
<li >5.   <a href="#rfc.section.5">Security Considerations</a>
</li>
<li >6.   <a href="#rfc.section.6">Acknowledgements</a>
</li>
<li >7.   <a href="#rfc.references">References</a>
</li>
<ul><li>7.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li >7.2.   <a href="#rfc.references.2">Informal References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">ES6 Sample Canonicalizer</a>
</li>
<li >Appendix B.   <a href="#rfc.appendix.B">Number Serialization Samples</a>
</li>
<li >Appendix C.   <a href="#rfc.appendix.C">Canonicalized JSON as "Wire Format"</a>
</li>
<li >Appendix D.   <a href="#rfc.appendix.D">Dealing with Big Numbers</a>
</li>
<li >Appendix E.   <a href="#rfc.appendix.E">Other JSON Canonicalization Efforts</a>
</li>
<li >Appendix F.   <a href="#rfc.appendix.F">Development Portal</a>
</li>
<li ><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#Introduction" id="Introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Cryptographic operations like hashing and 
signing depend on that the target data does not change during 
serialization, transport, or parsing.  A straightforward way of 
accomplishing this is converting the data into a format which has a 
simple and fixed representation like Base64Url <a href="#RFC4648" class="xref">[RFC4648]</a> which for example have been used in JWS <a href="#RFC7515" class="xref">[RFC7515]</a>.  Another solution is creating a canonicalized version of the target data with XML Signature <a href="#XMLDSIG" class="xref">[XMLDSIG]</a> as a prime example.  </p>
<p id="rfc.section.1.p.2">Since the objective was keeping the data "as 
is", the canonicalization method was selected.  For avoiding 
"reinventing the wheel", JCS relies on serialization of JSON data 
compatible with ECMAScript (aka JavaScript) beginning with version 6 <a href="#ES6" class="xref">[ES6]</a>, from now on simply referred to as "ES6".  </p>
<p id="rfc.section.1.p.3">Seasoned XML developers recalling difficulties
 getting signatures to validate (usually due to different 
interpretations of the quite intricate XML canonicalization rules as 
well as of the equally extensive Web Services security standards), may 
rightfully wonder why this particular effort would succeed. The reasons 
are twofold: </p>

<ul><li>JSON is a considerably simpler format than XML, as well as lacking support for the powerful (but complex) namespace concept.  </li>
<li style="margin-top:0.8em">ES6 compatible JSON serialization is already supported by most Web browsers, Node.js <a href="#NODEJS" class="xref">[NODEJS]</a>, as well as by third party libraries like Open&nbsp;Keystore <a href="#OPENKEY" class="xref">[OPENKEY]</a>, giving the proposed canonicalization scheme a head start.  </li>
</ul>

<p> </p>
<p id="rfc.section.1.p.4">The JCS specification describes how JSON 
serializing rules compliant with ES6 <i>combined with an elementary sorting
 scheme</i>, can be used for supporting "Crypto&nbsp;Safe" JSON.  </p>
<p id="rfc.section.1.p.5">JCS is compatible with some existing systems relying on JSON canonicalization such as JWK Thumbprint <a href="#RFC7638" class="xref">[RFC7638]</a> and Keybase <a href="#KEYBASE" class="xref">[KEYBASE]</a>.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#Terminology" id="Terminology">Terminology</a>
</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", 
"SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT 
RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be 
interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.  </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#Operation" id="Operation">Detailed Operation</a>
</h1>
<p id="rfc.section.3.p.1">This section describes the different issues related to JSON canonicalization, and how they are addressed by JCS.  </p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#json.datacreation" id="json.datacreation">Creation of JSON Data</a>
</h1>
<p id="rfc.section.3.1.p.1">In order to canonicalize JSON data, an internal representation of the JSON data is needed.  This can be achieved by: </p>
<p></p>

<ul><li>Parsing externally supplied JSON data.  </li>
<li style="margin-top:0.8em">Programmatic creation of JSON data.  </li>
</ul>

<p> </p>
<p id="rfc.section.3.1.p.3">Irrespective of method used, the JSON data MUST be compatible both with ES6 and I-JSON <a href="#RFC7493" class="xref">[RFC7493]</a>, which implies the following: </p>
<p></p>

<ul><li>There MUST NOT be any duplicate property names within an <samp>Object</samp>.  </li>
<li style="margin-top:0.8em">Data of the type <samp>String</samp> MUST be expressible as Unicode <a href="#UNICODE" class="xref">[UNICODE]</a> strings.  Also see <a href="#json.ser.string" class="xref">Section 3.2.2.2</a>.  </li>
<li style="margin-top:0.8em">Data of the type <samp>Number</samp> MUST be expressible as IEEE-754 <a href="#IEEE754" class="xref">[IEEE754]</a> double precision values.  Also see <a href="#json.ser.number" class="xref">Section 3.2.2.3</a>.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#json.canonicalization" id="json.canonicalization">Canonicalization of JSON Data</a>
</h1>
<p id="rfc.section.3.2.p.1">The following sub sections describe all the 
steps needed in order to create a canonicalized version of internal JSON
 data elaborated on in the previous section.  </p>
<p><a href="#canonicalize.js" class="xref">Appendix A</a> shows sample code for an ES6 based canonicalizer, matching the JCS specification.  </p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#json.whitespace" id="json.whitespace">Whitespace Handling</a>
</h1>
<p id="rfc.section.3.2.1.p.1">Whitespace between JSON elements MUST NOT be emitted.  </p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#json.serialization.data" id="json.serialization.data">Serialization of Primitive Data Types</a>
</h1>
<p id="rfc.section.3.2.2.p.1">Assume that you parse a JSON object like the following: </p>
<pre style="padding:1em 0.5em">  {
    "<span style="color:brown">numbers</span>": [<span style="color:green">333333333.33333329</span>, <span style="color:green">1E30</span>, <span style="color:green">4.50</span>,
                <span style="color:green">2e-3</span>, <span style="color:green">0.000000000000000000000000001</span>],
    "<span style="color:brown">string</span>": "<span style="color:royalblue">\u20ac$\u000F\u000aA'\u0042\u0022\u005c\\\"\/</span>",
    "<span style="color:brown">literals</span>": [<span style="color:green">null</span>, <span style="color:green">true</span>, <span style="color:green">false</span>]
  }</pre>
<p></p>
<p id="rfc.section.3.2.2.p.3">If you subsequently serialize the object created by the operation above using an serializer compliant with ES6's <samp>JSON.stringify()</samp>,
 the result would (with a line wrap added for display purposes only), be
 rather divergent with respect to representation of data: </p>
<pre style="padding:1em 0.5em">  {"<span style="color:brown">numbers</span>":[<span style="color:green">333333333.3333333</span>,<span style="color:green">1e+30</span>,<span style="color:green">4.5</span>,<span style="color:green">0.002</span>,<span style="color:green">1e-27</span>],"<span style="color:brown">string</span>":
  "<span style="color:royalblue">&#x20AC;$\u000f\nA'B\"\\\\\"/</span>","<span style="color:brown">literals</span>":[<span style="color:green">null</span>,<span style="color:green">true</span>,<span style="color:green">false</span>]}</pre>
<p> </p>
<p id="rfc.section.3.2.2.p.6">The reason for the notable difference 
between the parsed data and its serialized counterpart, is due to a wide
 tolerance on input data (as defined by JSON <a href="#RFC8259" class="xref">[RFC8259]</a>),
 while output data (as defined by ES6), has a fixed representation.  As 
can be seen by the example, numbers are subject to rounding as well.  <br><br>
 The following sub sections describe serialization of primitive JSON 
data types according to JCS.  This part is identical to that of ES6.  </p>
<h1 id="rfc.section.3.2.2.1">
<a href="#rfc.section.3.2.2.1">3.2.2.1.</a> <a href="#json.ser.literals" id="json.ser.literals">Serialization of Literals</a>
</h1>
<p id="rfc.section.3.2.2.1.p.1">The JSON literals <samp>null</samp>, <samp>true</samp>, and <samp>false</samp> present no challenge since they already have a fixed definition in JSON <a href="#RFC8259" class="xref">[RFC8259]</a>.  </p>
<h1 id="rfc.section.3.2.2.2">
<a href="#rfc.section.3.2.2.2">3.2.2.2.</a> <a href="#json.ser.string" id="json.ser.string">Serialization of Strings</a>
</h1>
<p id="rfc.section.3.2.2.2.p.1">For JSON data of the type <samp>String</samp> (which includes <samp>Object</samp> property names as well), each character MUST be serialized as described in Section <a href="#ES6" class="xref">24.3.2.2</a> of ES6.  <br><br>
 If the Unicode value falls within the traditional ASCII control 
character range (U+0000 through U+001F), it MUST be serialized using 
lowercase hexadecimal Unicode notation (\uhhhh) unless it is in the set 
of predefined JSON control characters U+0008, U+0009, U+000A, U+000C or 
U+000D which MUST be serialized as \b, \t, \n, \f and \r respectively.  <br><br>
 If the Unicode value is outside of the ASCII control character range, 
it MUST be serialized "as&nbsp;is" unless it is equivalent to 
U+005C&nbsp;(\) or U+0022&nbsp;(") which MUST be serialized as \\ and \"
 respectively.  <br><br> Finally, the serialized string value MUST be enclosed in double quotes (").  <br><br>
 Note that many JSON systems permit the use of invalid Unicode data like
 "lone&nbsp;surrogates" (e.g. U+DEAD), which also is dealt with in a 
platform specific way.  Since this leads to interoperability issues 
including broken signatures, such usages MUST be avoided.  <br><br> Note
 that although the Unicode standard offers a possibility combining 
certain characters into one, referred to as "Unicode Normalization" (<a href="https://www.unicode.org/reports/tr15/">https://www.unicode.org/reports/tr15/</a>), such functionality MUST be delegated to the application layer which already is the case for most other uses of JSON.  </p>
<h1 id="rfc.section.3.2.2.3">
<a href="#rfc.section.3.2.2.3">3.2.2.3.</a> <a href="#json.ser.number" id="json.ser.number">Serialization of Numbers</a>
</h1>
<p id="rfc.section.3.2.2.3.p.1">JSON data of the type <samp>Number</samp> MUST be serialized according to Section <a href="#ES6" class="xref">7.1.12.1</a>
 of ES6; for maximum interoperability preferably including the "Note 2" 
enhancement as well.  The latter is implemented by for example Google's 
V8 <a href="#V8" class="xref">[V8]</a>.  <br><br> Due to the relative complexity of this part, it is not included in this specification.  <br><br> Note that ES6 builds on the IEEE-754 <a href="#IEEE754" class="xref">[IEEE754]</a> double precision standard for storing <samp>Number</samp> data.  <a href="#json.ieee754.test" class="xref">Appendix B</a> holds a set of IEEE-754 sample values and their corresponding JSON serialization.  <br><br> Occasionally applications need higher precision or longer integers than offered by the current implementation of JSON <samp>Number</samp> in ES6.  <a href="#json.bignumbers" class="xref">Appendix D</a> outlines how this can be achieved in a portable and extensible way.  </p>
<h1 id="rfc.section.3.2.3">
<a href="#rfc.section.3.2.3">3.2.3.</a> <a href="#json.sorting.properties" id="json.sorting.properties">Sorting of Object Properties</a>
</h1>
<p id="rfc.section.3.2.3.p.1">Although the previous step indeed 
normalized the representation of primitive JSON data types, the result 
would not qualify as "canonicalized" since <samp>Object</samp> properties are not in lexicographic (alphabetical) order.  <br><br> Applied to the sample in <a href="#json.serialization.data" class="xref">Section 3.2.2</a>, a properly canonicalized version should (with a line wrap added for display purposes only), read as: </p>
<pre style="padding:1em 0.5em">  {"<span style="color:brown">literals</span>":[<span style="color:green">null</span>,<span style="color:green">true</span>,<span style="color:green">false</span>],"<span style="color:brown">numbers</span>":[<span style="color:green">333333333.3333333</span>,
  <span style="color:green">1e+30</span>,<span style="color:green">4.5</span>,<span style="color:green">0.002</span>,<span style="color:green">1e-27</span>],"<span style="color:brown">string</span>":"<span style="color:royalblue">&#x20AC;$\u000f\nA'B\"\\\\\"/</span>"}</pre>
<p> </p>
<p id="rfc.section.3.2.3.p.4">The rules for lexicographic sorting of JSON properties according to JCS are as follows: </p>

<ul><li>
<samp>Object</samp> properties are sorted in a recursive manner which means that a found JSON child <samp>Object</samp> type MUST be subject to sorting as well.  </li>
<li style="margin-top:0.8em">JSON <samp>Array</samp> data MUST also be checked for the presence of sortable JSON <samp>Object</samp> elements, but array element order MUST NOT be changed.  </li>
</ul>

<p> </p>
<p id="rfc.section.3.2.3.p.5">When a JSON <samp>Object</samp> is about to have its properties sorted, the following measures MUST be performed: </p>

<ul><li>Property strings to be sorted depend on that strings are represented
 as arrays of 16-bit unsigned integers where each integer holds a single
 UCS2/UTF-16 <a href="#UNICODE" class="xref">[UNICODE]</a> code unit.  The sorting is based on pure value comparisons, independent of locale settings.  </li>
<li style="margin-top:0.8em">Property strings either have different values at some index that is a
 valid index for both strings, or their lengths are different, or both. 
 If they have different values at one or more index positions, let k be 
the smallest such index; then the string whose value at position k has 
the smaller value, as determined by using the &lt; operator, 
lexicographically precedes the other string.  If there is no index 
position at which they differ, then the shorter string lexicographically
 precedes the longer string.  </li>
</ul>

<p> </p>
<p id="rfc.section.3.2.3.p.6">The rationale for basing the sort 
algorithm on UCS2/UTF-16 code units is that it maps directly to the 
string type in ECMAScript, Java and .NET.  Systems using another 
representation of string data will need to convert JSON property strings
 into arrays of UCS2/UTF-16 code units before sorting.  <br><br> Note: 
for the purpose obtaining a deterministic property order, sorting on 
UTF-8 or UTF-32 encoded data would also work, but the result would 
differ (and thus be incompatible with this specification).  </p>
<h1 id="rfc.section.3.2.4">
<a href="#rfc.section.3.2.4">3.2.4.</a> <a href="#json.utf8" id="json.utf8">UTF-8 Generation</a>
</h1>
<p id="rfc.section.3.2.4.p.1">Finally, in order to create a platform independent representation, the resulting JSON string data MUST be encoded in UTF-8.  <br><br> Applied to the sample in <a href="#json.sorting.properties" class="xref">Section 3.2.3</a> this should yield the following bytes here shown in hexadecimal notation: </p>
<pre style="padding:1em 0.5em">  7b 22 6c 69 74 65 72 61 6c 73 22 3a 5b 6e 75 6c 6c 2c 74 72
  75 65 2c 66 61 6c 73 65 5d 2c 22 6e 75 6d 62 65 72 73 22 3a
  5b 33 33 33 33 33 33 33 33 33 2e 33 33 33 33 33 33 33 2c 31
  65 2b 33 30 2c 34 2e 35 2c 30 2e 30 30 32 2c 31 65 2d 32 37
  5d 2c 22 73 74 72 69 6e 67 22 3a 22 e2 82 ac 24 5c 75 30 30
  30 66 5c 6e 41 27 42 5c 22 5c 5c 5c 5c 5c 22 2f 22 7d</pre>
<p></p>
<p id="rfc.section.3.2.4.p.3">This data is intended to be usable as input to cryptographic functions.  </p>
<p id="rfc.section.3.2.4.p.4">For other uses see <a href="#json.wireformat" class="xref">Appendix C</a>.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.4.p.1">This document has no IANA actions.  </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.5.p.1">JSON parsers MUST check that input data conforms to the JSON <a href="#RFC8259" class="xref">[RFC8259]</a> specification.  </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.6.p.1">Building on ES6 <samp>Number</samp> 
normalization was originally proposed by James Manger. This ultimately 
led to the adoption of the entire ES6 JSON processing model.  <br><br> 
Other people who have contributed with valuable input to this 
specification include Mike Samuel, Richard Gibson, Scott Ananian and 
Michal Wadas.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">7.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">7.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="ES6">[ES6]</b></td>
<td class="top">
<a>Ecma International</a>, "<a href="https://www.ecma-international.org/ecma-262/6.0/index.html">ECMAScript 2015 Language Specification</a>"</td>
</tr>
<tr>
<td class="reference"><b id="IEEE754">[IEEE754]</b></td>
<td class="top">
<a>IEEE</a>, "<a href="http://grouper.ieee.org/groups/754/">IEEE Standard for Floating-Point Arithmetic</a>", August 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7493">[RFC7493]</b></td>
<td class="top">
<a>Bray, T.</a>, "<a href="https://tools.ietf.org/html/rfc7493">The I-JSON Message Format</a>", RFC 7493, DOI 10.17487/RFC7493, March 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8259">[RFC8259]</b></td>
<td class="top">
<a>Bray, T.</a>, "<a href="https://tools.ietf.org/html/rfc8259">The JavaScript Object Notation (JSON) Data Interchange Format</a>", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017.</td>
</tr>
<tr>
<td class="reference"><b id="UNICODE">[UNICODE]</b></td>
<td class="top">
<a>The Unicode Consortium</a>, "<a href="https://www.unicode.org/versions/Unicode10.0.0/">The Unicode Standard, Version 10.0.0</a>"</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">7.2.</a> Informal References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="KEYBASE">[KEYBASE]</b></td>
<td class="top">"<a href="https://keybase.io/docs/api/1.0/canonical_packings#json">Keybase</a>"</td>
</tr>
<tr>
<td class="reference"><b id="NODEJS">[NODEJS]</b></td>
<td class="top">"<a href="https://nodejs.org/">Node.js</a>"</td>
</tr>
<tr>
<td class="reference"><b id="OPENAPI">[OPENAPI]</b></td>
<td class="top">"<a href="https://www.openapis.org/">The OpenAPI Initiative</a>"</td>
</tr>
<tr>
<td class="reference"><b id="OPENKEY">[OPENKEY]</b></td>
<td class="top">"<a href="https://github.com/cyberphone/openkeystore">Open Keystore</a>"</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, DOI 10.17487/RFC4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7515">[RFC7515]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a>", RFC 7515, DOI 10.17487/RFC7515, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7638">[RFC7638]</b></td>
<td class="top">
<a>Jones, M.</a> and <a>N. Sakimura</a>, "<a href="https://tools.ietf.org/html/rfc7638">JSON Web Key (JWK) Thumbprint</a>", RFC 7638, DOI 10.17487/RFC7638, September 2015.</td>
</tr>
<tr>
<td class="reference"><b id="V8">[V8]</b></td>
<td class="top">
<a>Google LLC</a>, "<a href="https://developers.google.com/v8/">Chrome V8 Open Source JavaScript Engine</a>"</td>
</tr>
<tr>
<td class="reference"><b id="XMLDSIG">[XMLDSIG]</b></td>
<td class="top">
<a>W3C</a>, "<a href="https://www.w3.org/TR/xmldsig-core1/">XML Signature Syntax and Processing Version 1.1</a>"</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#canonicalize.js" id="canonicalize.js">ES6 Sample Canonicalizer</a>
</h1>
<p id="rfc.section.A.p.1">Below is a functionally complete example of a JCS compliant canonicalizer for usage with ES6 based systems.  <br><br>
 Note: The primary purpose of this code is highlighting the 
canonicalization algorithm.  Using the full power of ES6 would reduce 
the code size considerably but would also be more difficult to follow by
 non-experts.  </p>
<pre style="padding:1em 0.5em">  <span style="color:blue">var</span> canonicalize = <span style="color:blue">function</span>(object) {
  
      <span style="color:blue">var</span> buffer = '<span style="color:green"></span>';
      serialize(object);
      <span style="color:blue">return</span> buffer;
  
      <span style="color:blue">function</span> serialize(object) {
          <span style="color:blue">if</span> (object === <span style="color:blue">null</span> || <span style="color:blue">typeof</span> object !== '<span style="color:green">object</span>') {
              <span style="color:#808080">/////////////////////////////////////////////////</span>
              <span style="color:#808080">// Primitive data type - Use ES6/JSON          //</span>
              <span style="color:#808080">/////////////////////////////////////////////////</span>
              buffer += <span style="color:brown">JSON</span>.stringify(object);
  
          } <span style="color:blue">else</span> <span style="color:blue">if</span> (<span style="color:brown">Array</span>.isArray(object)) {
              <span style="color:#808080">/////////////////////////////////////////////////</span>
              <span style="color:#808080">// Array - Maintain element order              //</span>
              <span style="color:#808080">/////////////////////////////////////////////////</span>
              buffer += '<span style="color:green">[</span>';
              <span style="color:blue">let</span> next = <span style="color:blue">false</span>;
              object.forEach((element) =&gt; {
                  <span style="color:blue">if</span> (next) {
                      buffer += '<span style="color:green">,</span>';
                  }
                  next = <span style="color:blue">true</span>;
                  <span style="color:#808080">/////////////////////////////////////////</span>
                  <span style="color:#808080">// Array element - Recursive expansion //</span>
                  <span style="color:#808080">/////////////////////////////////////////</span>
                  serialize(element);
              });
              buffer += '<span style="color:green">]</span>';
  
          } <span style="color:blue">else</span> {
              <span style="color:#808080">/////////////////////////////////////////////////</span>
              <span style="color:#808080">// Object - Sort properties before serializing //</span>
              <span style="color:#808080">/////////////////////////////////////////////////</span>
              buffer += '<span style="color:green">{</span>';
              <span style="color:blue">let</span> next = <span style="color:blue">false</span>;
              <span style="color:brown">Object</span>.keys(object).sort().forEach((property) =&gt; {
                  <span style="color:blue">if</span> (next) {
                      buffer += '<span style="color:green">,</span>';
                  }
                  next = <span style="color:blue">true</span>;
                  <span style="color:#808080">///////////////////////////////////////////////</span>
                  <span style="color:#808080">// Property names are strings - Use ES6/JSON //</span>
                  <span style="color:#808080">///////////////////////////////////////////////</span>
                  buffer += <span style="color:brown">JSON</span>.stringify(property);
                  buffer += '<span style="color:green">:</span>';
                  <span style="color:#808080">//////////////////////////////////////////</span>
                  <span style="color:#808080">// Property value - Recursive expansion //</span>
                  <span style="color:#808080">//////////////////////////////////////////</span>
                  serialize(object[property]);
              });
              buffer += '<span style="color:green">}</span>';
          }
      }
  };</pre>
<p></p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#json.ieee754.test" id="json.ieee754.test">Number Serialization Samples</a>
</h1>
<p id="rfc.section.B.p.1">The following table holds a set of ES6 <samp>Number</samp>
 serialization samples, including some edge cases.  The column 
"ES6&nbsp;Internal" refers to the internal ES6 representation of the <samp>Number</samp> data type which is based on the IEEE-754 <a href="#IEEE754" class="xref">[IEEE754]</a> standard using 64-bit (double precision) values, here expressed in hexadecimal.  </p>
<table style="margin-left:3em" class="tftable"><tr><th>ES6 Internal</th><th>JSON Representation</th><th>Comment</th></tr>
<tr><td><tt style="font-size:12pt">0000000000000000</tt></td><td>0                       </td><td>Zero               </td></tr>
<tr><td><tt style="font-size:12pt">8000000000000000</tt></td><td>0                       </td><td>Minus zero         </td></tr>
<tr><td><tt style="font-size:12pt">0000000000000001</tt></td><td>5e-324                  </td><td>Smallest pos number</td></tr>
<tr><td><tt style="font-size:12pt">8000000000000001</tt></td><td>-5e-324                 </td><td>Smallest neg number</td></tr>
<tr><td><tt style="font-size:12pt">7fefffffffffffff</tt></td><td>1.7976931348623157e+308 </td><td>Largest pos number </td></tr>
<tr><td><tt style="font-size:12pt">ffefffffffffffff</tt></td><td>-1.7976931348623157e+308</td><td>Largest neg number </td></tr>
<tr><td><tt style="font-size:12pt">433fffffffffffff</tt></td><td>9007199254740991        </td><td>Largest pos integer</td></tr>
<tr><td><tt style="font-size:12pt">c33fffffffffffff</tt></td><td>-9007199254740991       </td><td>Largest neg integer</td></tr>
<tr><td><tt style="font-size:12pt">7fffffffffffffff</tt></td><td>                        </td><td>Error (NaN)        </td></tr>
<tr><td><tt style="font-size:12pt">7ff0000000000000</tt></td><td>                        </td><td>Error (Infinity)   </td></tr>
<tr><td><tt style="font-size:12pt">44b52d02c7e14af5</tt></td><td>9.999999999999997e+22   </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">44b52d02c7e14af6</tt></td><td>1e+23                   </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">44b52d02c7e14af7</tt></td><td>1.0000000000000001e+23  </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">444b1ae4d6e2ef4e</tt></td><td>999999999999999700000   </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">444b1ae4d6e2ef4f</tt></td><td>999999999999999900000   </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">444b1ae4d6e2ef50</tt></td><td>1e+21                   </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">444b1ae4d6e2ef51</tt></td><td>1.0000000000000001e+21  </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">41b3de4355555553</tt></td><td>333333333.3333332       </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">41b3de4355555554</tt></td><td>333333333.33333325      </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">41b3de4355555555</tt></td><td>333333333.3333333       </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">41b3de4355555556</tt></td><td>333333333.3333334       </td><td>                   </td></tr>
<tr><td><tt style="font-size:12pt">41b3de4355555557</tt></td><td>333333333.33333343      </td><td>                   </td></tr>
</table>
<p></p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#json.wireformat" id="json.wireformat">Canonicalized JSON as "Wire Format"</a>
</h1>
<p id="rfc.section.C.p.1">Since the result from the canonicalization process (see <a href="#json.utf8" class="xref">Section 3.2.4</a>),
 is fully valid JSON, it can also be used as "Wire&nbsp;Format".  
However, this is just an option since cryptographic schemes based on 
JCS, <i>in most cases would not depend on that externally supplied JSON 
data already is canonicalized</i>.  <br><br> In fact, the ES6 standard way of serializing objects using <samp>JSON.stringify()</samp>
 produces a more "logical" format, where properties are kept in the 
order they were created or received.  The example below shows an address
 record which could benefit from ES6 standard serialization: </p>
<pre style="padding:1em 0.5em">  {
    "<span style="color:brown">name</span>": "<span style="color:royalblue">John Doe</span>",
    "<span style="color:brown">address</span>": "<span style="color:royalblue">2000 Sunset Boulevard</span>",
    "<span style="color:brown">city</span>": "<span style="color:royalblue">Los Angeles</span>",
    "<span style="color:brown">zip</span>": "<span style="color:royalblue">90001</span>",
    "<span style="color:brown">state</span>": "<span style="color:royalblue">CA</span>"
  }</pre>
<p></p>
<p id="rfc.section.C.p.3">Using canonicalization the properties above 
would be output in the order "address", "city", "name", "state" and 
"zip", which adds fuzziness to the data from a human (developer or 
technical support), perspective.  </p>
<p id="rfc.section.C.p.4">That is, for many applications, 
canonicalization would only be used internally for creating a "hashable"
 representation of the data needed for cryptographic operations.  </p>
<p id="rfc.section.C.p.5">Note that if message size is not a concern, 
you may even "Pretty&nbsp;Print" JSON data on the wire, since whitespace
 is ignored regardless of format chosen.  </p>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#json.bignumbers" id="json.bignumbers">Dealing with Big Numbers</a>
</h1>
<p id="rfc.section.D.p.1">There are two major issues associated with the JSON <samp>Number</samp> type, here illustrated by the following sample object: </p>
<pre style="padding:1em 0.5em">  {
    "<span style="color:brown">giantNumber</span>": <span style="color:green">1.4e+9999</span>,
    "<span style="color:brown">payMeThis</span>": <span style="color:green">26000.33</span>,
    "<span style="color:brown">int64Max</span>": <span style="color:green">9223372036854775807</span>
  }</pre>
<p></p>
<p id="rfc.section.D.p.3">Although the sample above conforms to JSON (according to <a href="#RFC8259" class="xref">[RFC8259]</a>), there are some practical hurdles to consider: </p>
<p></p>

<ul><li>Standard JSON parsers rarely process "giantNumber" in a meaningful 
way.  64-bit integers like "int64Max" normally pass through parsers, but
 in systems like ES6, <i>at the expense of lost precision</i>.  </li>
<li style="margin-top:0.8em">Another issue is that parsers typically would use different schemes 
for handling "giantNumber" and "int64Max".  In addition, monetary data 
like "payMeThis" would presumably not rely on a floating point system 
due to rounding issues with respect to decimal arithmetic.  <br><br> The (to the author NB), only known way handling this kind of "overloading" of the <samp>Number</samp>
 type (at least in an extensible manner), is through mapping mechanisms,
 instructing parsers what to do with different properties based on their
 name.  However, this greatly limits the value of using the <samp>Number</samp> type outside of its original somewhat constrained, JavaScript context.  </li>
</ul>

<p> </p>
<p id="rfc.section.D.p.5">For usage with JCS (<i>and in fact for any usage 
of JSON by multiple parties potentially using independently developed 
software</i>), numbers that do not have a natural place in the current JSON 
ecosystem MUST be wrapped using the JSON <samp>String</samp> type.  This is close to a de-facto standard for open systems.  <br><br> Aided by a mapping system; be it programmatic like </p>
<pre style="padding:1em 0.5em">  <span style="color:blue">var</span> obj = <span style="color:brown">JSON</span>.parse('<span style="color:green">{"giantNumber": "1.4e+9999"}</span>');
  <span style="color:blue">var</span> biggie = <span style="color:blue">new</span> BigNum(obj.giantNumber);</pre>
<p></p>
<p id="rfc.section.D.p.7">or declarative schemes like OpenAPI <a href="#OPENAPI" class="xref">[OPENAPI]</a>, there are no real limits, not even when using ES6.  </p>
<h1 id="rfc.appendix.E">
<a href="#rfc.appendix.E">Appendix E.</a> <a href="#json.otherefforts" id="json.otherefforts">Other JSON Canonicalization Efforts</a>
</h1>
<p id="rfc.section.E.p.1">There are (and have been) other efforts creating "Canonical JSON".  Below is a list of URLs to some of them: </p>

<ul><li>
<a href="https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00">https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-00</a> </li>
<li style="margin-top:0.8em">
<a href="https://gibson042.github.io/canonicaljson-spec/">https://gibson042.github.io/canonicaljson-spec/</a> </li>
<li style="margin-top:0.8em">
<a href="https://www.npmjs.com/package/canonical-json">https://www.npmjs.com/package/canonical-json</a> </li>
<li style="margin-top:0.8em">
<a href="http://wiki.laptop.org/go/Canonical_JSON">http://wiki.laptop.org/go/Canonical_JSON</a> </li>
</ul>

<p> </p>
<h1 id="rfc.appendix.F">
<a href="#rfc.appendix.F">Appendix F.</a> <a href="#json.development" id="json.development">Development Portal</a>
</h1>
<p id="rfc.section.F.p.1">The JSC specification is currently developed at <a href="https://github.com/cyberphone/json-canonicalization">https://github.com/cyberphone/json-canonicalization</a>.  <br><br> The portal also provides software for testing.  </p>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Anders Rundgren</span> 
	  <span class="n hidden">
		<span class="family-name">Rundgren</span>
	  </span>
	</span>
	<span class="org vcardline">Independent</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Montpellier</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:anders.rundgren.net@gmail.com">anders.rundgren.net@gmail.com</a></span>

<span class="vcardline">URI: <a href="https://www.linkedin.com/in/andersrundgren/">https://www.linkedin.com/in/andersrundgren/</a></span>

  </address>
</div>



</body></html>
